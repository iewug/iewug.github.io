<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; --title-bar-height:20px; }
.mac-os-11 { --title-bar-height:28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
span.cm-underlined { text-decoration: underline; }
span.cm-strikethrough { text-decoration: line-through; }
.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }
.cm-tw-deleted { text-decoration: line-through; }
.cm-tw-header5 { font-weight: 700; }
.cm-tw-listitem:first-child { padding-left: 10px; }
.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }
.cm-tw-underline { text-decoration: underline; }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

/* open-sans-regular - latin-ext_latin */
  /* open-sans-italic - latin-ext_latin */
    /* open-sans-700 - latin-ext_latin */
    /* open-sans-700italic - latin-ext_latin */
  html {
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
}

body {
    font-family: "Open Sans","Clear Sans", "Helvetica Neue", Helvetica, Arial, 'Segoe UI Emoji', sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1024px;
	}
}

@media only screen and (min-width: 1800px) {
	#write {
		max-width: 1200px;
	}
}

#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}

/*@media print {
    .typora-export h1,
    .typora-export h2 {
        border-bottom: none;
        padding-bottom: initial;
    }

    .typora-export h1::after,
    .typora-export h2::after {
        content: "";
        display: block;
        height: 100px;
        margin-top: -96px;
        border-top: 1px solid #eee;
    }
}*/

h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table th:first-child,
table td:first-child {
    margin-top: 0;
}
table th:last-child,
table td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    table,
    pre {
        page-break-inside: avoid;
    }
    pre {
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.md-lang {
    color: #b4654d;
}

/*.html-for-mac {
    --item-hover-bg-color: #E6F0FE;
}*/

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
    opacity: 0.4;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}

.menu-item-container a.menu-style-btn {
    background-color: #f5f8fa;
    background-image: linear-gradient( 180deg , hsla(0, 0%, 100%, 0.8), hsla(0, 0%, 100%, 0)); 
}



mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}

g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

.MathJax g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}
mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
							stroke-width: 0;
						}
</style><title>笔记_现代操作系统</title>
</head>
<body class='typora-export'><div class='typora-export-content'>
<div id='write'  class=''><h1 id='现代操作系统笔记'><span>《现代操作系统》笔记</span></h1><p style="text-align: right;">
    Gu Wei 2022年6月
</p><p>&nbsp;</p><p><span>书看的是《现代操作系统》（英文版，第四版），Andrew S. Tanenbaum和Herbert Bos著，机械工业出版社。书的原名是《Modern Operating Systems》。本人在大二下学期花了十二周的时间看完了1~6章：引论、进程与线程、内存理、文件系统、输入输出、死锁。这便涵盖了操作系统的基本知识，而关于虚拟机、多处理机系统、安全以及案例研究，这些进阶知识就不再学习了。后续又根据上海交通大学CS2302课程大纲，简单整理了分布式系统和分布式文件系统。</span></p><p><span>书看的是比较仔细的，整理大多都是按照章节顺序进行整理的。个人认为可以作为相当优秀的讲稿或者自学材料。限于水平，疏忽和误解在所难免。</span></p><hr /><p>&nbsp;</p><h2 id='一引论'><span>一、引论</span></h2><p><span>第一章略读为主，这里稍作整理。</span></p><h3 id='11-操作系统是什么'><span>1.1 操作系统是什么</span></h3><p><span>操作系统扮演了两个重要角色：</span></p><ul><li><span>提供给程序一个干净的资源的抽象，而不是乱七八糟的硬件。</span></li><li><span>管理这些硬件，如CPU调度、磁盘分配。</span></li></ul><p><span>事实上，操作系统与用户模式下的程序之间的边界比较模糊。运行在</span><strong><span>内核模式（kernel mode）</span></strong><span>的程序是操作系统的一部分，但是一些运行在</span><strong><span>用户模式（user mode）</span></strong><span>下的程序也可以说是操作系统的一部分。比如修改密码虽然是运行在用户模式下，但是它执行了敏感的操作，需要被保护。在嵌入式系统中，甚至可能都没有内核模式，操作系统的边界就更模糊了。</span></p><h3 id='12-了解一点历史'><span>1.2 了解一点历史</span></h3><p><span>可能有出入，当作戏说也罢。作为一个出生在Windows XP时代的人，很难想象当初电脑的操作（尤其是打孔卡）。</span></p><ul><li><strong><span>1946</span></strong><span>年ENIAC诞生，利用了大量</span><strong><span>真空管</span></strong><span>，编程通过插拔电缆实现。</span></li><li><strong><span>1955-65晶体管</span></strong><span>计算机出现了，这些机器称为</span><strong><span>大型机（mainframe）</span></strong><span>，编程可以写FORTRAN高级语言或者汇编，然后打孔在</span><strong><span>打孔卡（punched card）</span></strong><span>上。为了加快效率，</span><strong><span>批处理系统（batch system）</span></strong><span>出现了：大家先写程序在打孔卡上，攒到一定程度后交给IBM1401生成磁带；然后把磁带交给IBM7094计算；将生成的磁带交给IBM1401打印出来。此时有操作系统了，主要就是帮助机器完成上述任务。</span></li><li><strong><span>1965-80集成电路</span></strong><span>出现了。当初不同的机器有着不同的架构和指令集，有专门为科学计算设计的，有专门为商业设计的。这导致这个机器可以运行的程序，那个机器就不行。IBM做了一件大胆的事情，设计了System/360机器以及它的操作系统OS/360，来应对所有的用户群体。即便bug很多，System/360大获成功。值得一提的是，System/360还是采用了打孔卡来输入程序。同时一些重要的思想也推广开：</span><strong><span>多道程序设计（multiprogramming）</span></strong><span>——内存中可以同时存在若干</span><strong><span>作业（job）</span></strong><span>、</span><strong><span>分时（timesharing）</span></strong><span>——多个人可以同时使用机器。Timesharing最有代表的是相容分时系统CTSS以及之后的MULTICS。虽然MULTICS最后是个半成品，但是成功孕育了UNIX系统。UNIX被AT&amp;T拿去开发成了System V，被伯克利拿去开发成了BSD。为了使两者相容，IEEE提出了POSIX标准，要求UNIX系统要遵循的一些规定。本书作者为了教育目的，模仿UNIX写了MINIX。而据称Linus受MINIX影响写了Linux。</span></li><li><strong><span>1980-Present大规模集成电路</span></strong><span>出现。个人电脑（也称作</span><strong><span>微机microcomputer</span></strong><span>）出现了。1974年英特尔造出来了第一款通用目的八位处理器8080，并希望一款操作系统。英特尔顾问Kildall就为8080造了一个控制器来控制一款新发布的磁盘，随后又写出了基于磁盘的操作系统CP/M(control program for microcomputers)，统治了整个微机市场。1980年代初，IBM联系比尔盖茨，希望获得他的BASIC解释器的授权，同时咨询比尔盖茨关于能运行在IBM PC上的操作系统。比尔盖茨推荐了Kildall，然而Kildall拒绝为IBM写相关操作系统，导致了比尔盖茨为IBM购买了别人写的DOS（磁盘操作系统）系统，随后又修改成MS-DOS系统，而CP/M也从此被MS-DOS打败。注意到此时的电脑完全是命令行交汇的。1960年代出现了图形用户界面GUI，率先被施乐（Xerox）研究员采纳。GUI最早成功的商用是乔布斯的苹果电脑。苹果公司后来采用了OS X操作系统，这是一款来源于FreeBSD的操作系统。而微软公司受苹果公司的影响，也提出了有用户界面的Windows操作系统。UNIX下X Window System（也称为X11）包含了一些基本的GUI，而Gnome和KDE则运行在X11之上，提供更好的GUI体验。</span></li><li><strong><span>1990-Present移动计算机</span></strong><span>。智能手机最早大规模使用塞班系统，但是市场不断被苹果的IOS系统和RIM的Blackberry系统侵占。当下最流行的当属谷歌的安卓系统（基于Linux）。</span></li></ul><h3 id='13-一些惊人的事实'><span>1.3 一些惊人的事实</span></h3><p><span>后面几节介绍了硬件、当下操作系统大观园、基本操作系统概念、系统调用、操作系统结构、C语言、一些操作系统的研究、本书概要和公制单位。这里不一一记录了，只摘取部分惊人事实。</span></p><ul><li><p><strong><span>硬件</span></strong><span>。操作系统通过驱动控制主板上的IO设备的控制器，控制器再控制IO设备。驱动作为操作系统的一部分，要在内核模式下运行，大多安装驱动要重启电脑（relink the driver with the kernel or make an entry in OS），而现在USB驱动大多支持即插即用。控制器也有寄存器，可以映射到操作系统的地址空间（memory mapped I/O），也可以将寄存器放在I/O port space中（separate I/O）。此外，SATA和M.2是接口、PCIe是总线（bus），PCI要传32位数据要32个并行wire，而PCIe只需要一根lane。</span></p></li><li><p><strong><span>操作系统大观园</span></strong><span>。</span></p><ul><li><strong><span>大型机（mainframe）</span></strong><span>通常房间大小，具有上千张磁盘，主要用作数据中心、高端网络服务器等。大型机操作系统一般提供</span><strong><span>批处理（batch）</span></strong><span>——用户将一批作业提交给操作系统后就不再干预、由操作系统控制它们自动运行，</span><strong><span>交易处理（transaction processing）</span></strong><span>——处理大量小请求、譬如银行支票处理和机票预定，以及</span><strong><span>分时（timesharing）</span></strong><span>——多个用户同时使用。Linux常被选作为大型机操作系统。</span></li><li><strong><span>服务器</span></strong><span>可以是个人电脑、工作站或者是大型机，它通过网络允许用户访问服务器上的硬件软件资源。常见操作系统有Solaris, FreeBSD, Linux and Windows Server。</span></li><li><strong><span>嵌入式</span></strong><span>（电视机、汽车等）系统有Embedded Linux, QNX, VxWorks操作系统。</span></li><li><strong><span>实时操作系统（real-time operating system）</span></strong><span>有软实时（soft real-time system）和硬实时（hard real-time system）之说，硬实时要求相关操作必须在一定时间内完成，软实时则要求操作尽量不要超过deadline。工业上控制系统常为实时操作系统，比如流水线上焊接机器人焊接过早或过晚都会gg。</span></li><li><span>智能卡（IC 卡）也有操作系统，和Java有关。</span></li></ul></li><li><p><strong><span>系统调用（system call）</span></strong><span>的例子。以</span><code>read(fd, buffer, nbytes)</code><span>为例。1. 按照nbytes、&amp;buffer、fd的顺序压入栈；2. 调用read函数，这个library procedure一般是用汇编写的，通常put the system-call number in a place where the OS expects it, such as a register；3. 触发</span><strong><span>陷阱（trap）</span></strong><span>异常，转到内核模式；4. 内核根据system-call number通过检索表找到相关handler，并处理该异常；5. 返回到调用者，回到用户模式；6. 清除刚刚分配的栈</span></p><p><span>POSIX要求的函数大多是系统调用函数，但是并不是一对一的。</span></p></li><li><p><strong><span>操作系统结构</span></strong><span>。单体系统（monolithic system）——整个操作系统是一个单一的程序，简单实现，容易奔溃。分层系统（layered system）——不同层次有不同的功能和权限。微内核（microkernel）——将操作系统模块化，部分奔溃不会导致整个程序奔溃。此外还有客户端-服务器模型、虚拟机（用软件模拟一个可以独立使用的电脑主机的硬件环境）和外核等结构。</span></p></li></ul><hr /><div style="page-break-after: always;"></div> <h2 id='二进程与线程'><span>二、进程与线程</span></h2><p><span>本章整理按照书上顺序：进程、线程、进程间通信、调度、经典IPC问题。本书其实不是很关心UNIX下具体的实现，而是更关心思想和概念层面。</span></p><p><span>在开始前，应该复习一下异常类型</span><a href='https://iewug.github.io/book/csapp/chapter8.html'><span>Chapter 8.1</span></a><span>。强调一下</span><strong><span>中断（interrupt）</span></strong><span>的一种实现为：I/O设备由INTR线告诉CPU中断发生，CPU发送ACK信号告知收到中断，I/O设备通过数据总线把中断号identifier发送给CPU，CPU在</span><strong><span>中断向量（interrupt vector）</span></strong><span>找到对应的中断处理程序的地址。中断我们特别关心的是</span><strong><span>时钟中断（clock interrupt）</span></strong><span>，每次时钟中断时，调度程序将获得CPU，判断是否要换个进程执行（当然其他I/O中断也会触发调度）。系统调用触发的是</span><strong><span>陷阱（trap）</span></strong><span>异常，程序会陷入内核模式运行。对于</span><code>read</code><span>系统调用，如果缓存里没有数据，就会产生</span><strong><span>缺页故障（page fault）</span></strong><span>， 使调用者阻塞。</span></p><h3 id='21-进程'><span>2.1 进程</span></h3><h4 id='211-进程模型'><span>2.1.1 进程模型</span></h4><p><span>进程定义为运行中的程序。在多道程序设计中，CPU在内存中多个程序中来回切换，提供了每个进程独占CPU的假象。这称为</span><strong><span>并发（concurrency）</span></strong><span>或者称为</span><strong><span>伪并行（pseudoparallelism）</span></strong><span>。注意到每次运行进程的速度和时长是不确定的，若要限制进程的开始结束时间，需要一些额外的操作，这是实时操作系统关心的事情。</span></p><p><span>再强调一下，</span><strong><span>程序（program）</span></strong><span>只是一些存在磁盘上的数据，一个程序跑两次，会有两个进程。</span></p><h4 id='212-进程创建creation'><span>2.1.2 进程创建Creation</span></h4><p><span>一个简单的操作系统（比如微波炉里的控制器）可能在开机的时候就运行所有的进程。对于一个通用目的的操作系统来说，有以下创建进程的情况：</span></p><ul><li><span>开机时，会创建很多进程。一些是前台foreground进程，负责与用户交互并为他们执行任务；一些是后台background进程，它们与特定的用户无关，但执行一些特殊功能——接收email，服务器处理客户的网页请求等。这些后台运行的、系统启动就存在的、不予任何终端关联的进程称为</span><strong><span>守护进程（daemon）</span></strong><span>。</span></li><li><span>运行中的进程可以通过system call来创建进程</span></li><li><span>用户可以通过点击图标或输入指令来创建进程</span></li><li><span>大型机的批处理系统中，当操作系统认为它有足够资源来运行另一个作业时，它会创建一个新的进程来运行输入队列的下一个作业。</span></li></ul><p><span>从技术上来看，这些进程的创建都是通过一个现有的进程执行了一个进程创建的系统调用。UNIX下只有</span><code>fork</code><span>唯一一个系统调用可以创建新进程。</span><code>fork</code><span>出的子进程和父进程有互相独立的地址空间（这使得父子进程在修改全局变量时不会影响到对方，同时读写文件还是会产生竞态），但是这两个地址空间上的内容完全相同。UNIX下</span><code>fork</code><span>完后常进行</span><code>execve</code><span>，</span><code>execve</code><span>会替换掉该进程的所有地址空间。而Windows下直接把进程创建和加载程序合并为一条指令了。UNIX之所以要把两者分开，是为了在</span><code>fork</code><span>之后运行代码的机会，譬如shell实现重定向，就是在fork之后关闭了标准输出，打开了重定向文件。</span></p><p><span>最后，还有</span><strong><span>写时复制（copy-on-write）</span></strong><span>技术。很多时候fork完就直接execve了，完全没有必要在fork时就把内存空间复制到另一块去。写时复制大体上就是虚拟地址被写入时，相应物理地址上的数据才被复制。</span></p><h4 id='213-进程终止termination'><span>2.1.3 进程终止Termination</span></h4><p><span>进程有以下几种终止情况：</span></p><ul><li><span>Normal exit (voluntary)——调用</span><code>exit</code><span>系统调用</span></li><li><span>Fatal error (involuntary)——譬如编译一个不存在的程序</span></li><li><span>Error exit (voluntary)——进程在运行过程中发现了bug（如除以零、访问不存在的内存等），可以告诉操作系统自己来处理错误，如果处理程序能修复故障，则重新执行引发中断的当前指令，否则处理程序返回到内核的abort例程，终止应用程序。    </span></li><li><span>Killed by another process (involuntary)——利用</span><code>kill</code><span>可以杀死其他进程，注意到UNIX下父进程被杀死，子进程不会被杀死，成为僵尸进程。</span></li></ul><h4 id='214-进程层次结构'><span>2.1.4 进程层次结构</span></h4><p><span>父进程和子进程及其后代子孙形成了</span><strong><span>进程组（process group）</span></strong><span>。</span><strong><span>信号（signal）</span></strong><span>可以传到进程组中的每一个进程（当然也可以是一个进程），进程可以捕获、忽略或者默认下被信号杀死。关于信号更多内容参考</span><a href='https://iewug.github.io/book/csapp/chapter8.html'><span>Chapter 8.4</span></a><span>。信号是软件层面上的，而中断是硬件层面上的。</span></p><p><span>UNIX启动时，第一个用户级进程是</span><code>init</code><span>进程，它将读取系统初始化表格，并为每个终端创建进程来等待用户登陆。</span></p><p><span>Windows并没有进程层次结构的概念，所有的进程都是平等的。创建新进程的时候，父进程会被给予一个handle来控制子进程，但是这个handle可以随便地分发给其他进程。而UNIX下父进程是无法不要它的孩子的。</span></p><h4 id='215-进程状态'><span>2.1.5 进程状态</span></h4><p><span>进程有以下三种状态：</span></p><ul><li><strong><span>Running</span></strong><span> (actually using the CPU at that instant)</span></li><li><strong><span>Ready</span></strong><span> (runnable; temporarily stopped to let another process run)</span></li><li><strong><span>Blocked</span></strong><span> (unable to run until some external event happens)</span></li></ul><p><span>在一些系统下，一个running态的进程发现自己无法继续，就调用</span><code>pause</code><span>系统调用，转入blocked态；调度器通过某些算法选取一个在ready态的进程执行；当running态的进程运行够久的话，抢占式的调度器会在时钟中断时将该进程转到ready态，并运行其他ready态的进程；而blocked的进程在外部事件发生后（比如收到IO设备的完成信号），又会重新回到ready态。</span></p><p><span>csapp上认为进程有：running、stopped、terminated三种状态。事实上都大差不差。个人觉得加个terminated状态会更完整。</span></p><h4 id='216-进程实现'><span>2.1.6 进程实现</span></h4><p><span>主要讨论：中断的进程如何可以回到中断前一模一样的状态。</span></p><p><span>首先操作系统维护了</span><strong><span>进程表（process table）</span></strong><span>，每个进程在上面都有一个</span><strong><span>entry（条目</span></strong><span>，或者称为</span><strong><span>进程控制块process control block, PCB）</span></strong><span>。每个entry包含了进程各种相关信息，如：</span></p><ul><li><strong><span>Process management</span></strong><span>: Registers, PC, PSW (program status word), Stack pointer, Process state, Priority, Scheduling parameters, PID, Parent process, Process group, Signals, Time when process started, CPU time used, Children&#39;s CPU time, Time of next alarm</span></li><li><strong><span>Memory management</span></strong><span>: Pointer to text/data/stack segment info</span></li><li><strong><span>File management</span></strong><span>: Root directory, Working directory, File descriptors, User ID, Group ID</span></li></ul><p><span>中断发生时：</span></p><ol start='' ><li><span>硬件把PC、PSW以及一些寄存器压入栈</span></li><li><span>CPU通过数据总线上的中断号从</span><strong><span>中断向量（interrupt vector）</span></strong><span>——存了所有中断处理程序的地址，加载新的PC</span></li><li><span>汇编程序在进程表里保存寄存器</span></li><li><span>汇编程序创建新的栈，之前硬件的栈被丢弃</span></li><li><span>C中断处理程序处理中断</span></li><li><span>调度器决定下一个运行的进程</span></li><li><span>C程序回到汇编代码</span></li><li><span>汇编程序创建新的进程</span></li></ol><p><span>之所以保存寄存器和设置栈指针要用汇编写，是因为C程序没办法实现这一点。</span></p><h4 id='217-多道程序设计模型'><span>2.1.7 多道程序设计模型</span></h4><p><span>在多道程序设计模型下，我们可以通过概率的角度来估算CPU利用率：</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n133" cid="n133" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="25.566ex" height="2.08ex" role="img" focusable="false" viewBox="0 -725.5 11300.3 919.5" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.439ex;"><defs><path id="MJX-3-TEX-I-1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path><path id="MJX-3-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path><path id="MJX-3-TEX-I-1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path><path id="MJX-3-TEX-N-A0" d=""></path><path id="MJX-3-TEX-I-1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-3-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-3-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-3-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-3-TEX-I-1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path><path id="MJX-3-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-3-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-3-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-3-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-3-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-3-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-3-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D436" xlink:href="#MJX-3-TEX-I-1D436"></use></g><g data-mml-node="mi" transform="translate(760,0)"><use data-c="1D443" xlink:href="#MJX-3-TEX-I-1D443"></use></g><g data-mml-node="mi" transform="translate(1511,0)"><use data-c="1D448" xlink:href="#MJX-3-TEX-I-1D448"></use></g><g data-mml-node="mtext" transform="translate(2278,0)"><use data-c="A0" xlink:href="#MJX-3-TEX-N-A0"></use></g><g data-mml-node="mi" transform="translate(2528,0)"><use data-c="1D462" xlink:href="#MJX-3-TEX-I-1D462"></use></g><g data-mml-node="mi" transform="translate(3100,0)"><use data-c="1D461" xlink:href="#MJX-3-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(3461,0)"><use data-c="1D456" xlink:href="#MJX-3-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(3806,0)"><use data-c="1D459" xlink:href="#MJX-3-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(4104,0)"><use data-c="1D456" xlink:href="#MJX-3-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(4449,0)"><use data-c="1D467" xlink:href="#MJX-3-TEX-I-1D467"></use></g><g data-mml-node="mi" transform="translate(4914,0)"><use data-c="1D44E" xlink:href="#MJX-3-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(5443,0)"><use data-c="1D461" xlink:href="#MJX-3-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(5804,0)"><use data-c="1D456" xlink:href="#MJX-3-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(6149,0)"><use data-c="1D45C" xlink:href="#MJX-3-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(6634,0)"><use data-c="1D45B" xlink:href="#MJX-3-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(7511.8,0)"><use data-c="3D" xlink:href="#MJX-3-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(8567.6,0)"><use data-c="31" xlink:href="#MJX-3-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(9289.8,0)"><use data-c="2212" xlink:href="#MJX-3-TEX-N-2212"></use></g><g data-mml-node="msup" transform="translate(10290,0)"><g data-mml-node="mi"><use data-c="1D45D" xlink:href="#MJX-3-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(536,413) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-3-TEX-I-1D45B"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>C</mi><mi>P</mi><mi>U</mi><mtext>&nbsp;</mtext><mi>u</mi><mi>t</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>z</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mn>1</mn><mo>−</mo><msup><mi>p</mi><mi>n</mi></msup></math></mjx-assistive-mml></mjx-container></div></div><p><span>上式中p是进程等待IO的时长占比，n是进程数量。该模型认为进程之间互相独立，虽然粗糙，但是可以看出进程越多，CPU利用率可以越大。</span></p><h3 id='22-线程'><span>2.2 线程</span></h3><h4 id='221-线程的使用'><span>2.2.1 线程的使用</span></h4><p><span>一个进程下的多个线程共享地址空间（这也意味着他们共享全局变量）。需要线程是基于以下考虑：一些应用需要多个活动同时进行，而这些活动需要共享部分数据；线程更轻量，更容易被创建和销毁；提升性能，对于那些需要大量CPU计算和IO读写的程序，使用线程可以将两者重叠；多核下线程很有用（具体本整理不讨论）。</span></p><p><span>举两个例子：</span></p><p><span>例一：一个文本处理器处理一份800页的文件。现在用户修改第一页的数据后，想要跳转到600页。若没有线程，处理器在修改好第一页数据后，再逐一调整后面的页码，最后才能读取用户的输入的跳转页码，势必会造成运行缓慢。若有线程，在修改第一页的同时，另一个线程就在重排版所有页面，同时还有一个线程监听键盘输入，在用户输入完跳转页面时，重排版工作已经完成，能立刻跳转。此外我们还可以加入一个自动保存的线程。</span></p><p><span>例二：一个网络服务器需要处理页面请求，然后把磁盘或者高速缓存里的数据发送客户端。下面有三个方案。</span></p><figure><table><thead><tr><th><span>Model</span></th><th><span>Characteristics</span></th></tr></thead><tbody><tr><td><span>Threads</span></td><td><span>Parallelism, blocking system calls</span></td></tr><tr><td><span>Single-threaded process</span></td><td><span>No parallelism, blocking system calls</span></td></tr><tr><td><span>Finite-state machine</span></td><td><span>Parallelism, nonblocking system calls, interrupts</span></td></tr></tbody></table></figure><ul><li><span>方案一是利用多线程。一个dispatcher线程负责把请求分配给闲置（i.e. blocked）的worker线程。worker线程如果在缓存中找到数据，就把数据发送给客户端，然后阻塞。如果没有找到的话，就用</span><code>read</code><span>系统调用请求磁盘读取，然后阻塞，磁盘返回后，该线程再变为ready态，等待调度。</span></li><li><span>方案二是利用单线程。该线程获得一个请求，然后检查、执行。当要等待磁盘的时候，CPU就闲置了。这就导致了CPU利用率低。</span></li><li><span>方案三也是单线程，但是采用了非阻塞的系统调用——不会产生阻塞而是返回一个error。当要从磁盘读取时，将目前线程的相关状态存在表格中，再执行下一个事件。磁盘完成读取也是通过信号或者中断来告知。每次从一个请求转到另一个请求，要求计算的状态被显式地保存在表格中。计算有一个保存的状态，并存在一些事件可以改变状态，这便是</span><strong><span>有限状态机（finite-state machine）</span></strong><span>。它虽然可以并行，但是要求了非阻塞系统调用以及中断，因此具有实现上的困难。实际上，这是通过单线程模拟了多线程。</span></li></ul><h4 id='222-经典线程模型'><span>2.2.2 经典线程模型</span></h4><p><strong><span>线程与进程的区别</span></strong></p><p><span>这句话很经典，需记住：Processes are used to group resources together; threads are the entities scheduled for execution on the CPU. </span></p><ul><li><span>进程有一个独立的地址空间包含了程序文本和数据，以及打开文件、子进程、等待中的信号、信号处理程序等等资源，把这些东西以进程的形式组合起来，能更好的管理使用。</span></li><li><span>线程就是运行在进程上下文中的逻辑流，每个进程开始生命周期时都是单一线程的，该线程称为</span><strong><span>主线程（Main Thread）</span></strong><span>，该主线程可以创建一个</span><strong><span>对等线程（Peer Thread）</span></strong><span>，由此这两个线程就并发执行。每个线程都有自己的线程上下文，包括一个唯一的整数线程ID、栈、栈指针、程序计数器、通用目的寄存器和条件码，且每个线程有自己的栈用来保存局部变量。内核会负责线程之间的调度。所有运行在一个进程里的线程共享该进程的整个虚拟地址空间，包括代码、数据、堆、共享库和打开的文件，这些与一个进程相关的线程组成一个对等线程池。线程之间不是父子关系，而是</span><strong><span>对等关系</span></strong><span>，即一个线程可以杀死它的任意对等线程，或等待它的任意对等线程终止。而主线程和对等线程的区别仅仅是主线程是进程中第一个运行的线程。</span></li></ul><p><strong><span>同一进程下，线程共享和独享内容：</span></strong></p><ul><li><strong><span>线程共享</span></strong><span>：Address space, Global variables, Open files, Child processes, Pending alarms, Signals and signal handlers, Accounting information (这是啥)</span></li><li><strong><span>线程独享</span></strong><span>：Program counter, Registers, Stack, State</span></li></ul><p><span>多个线程在同一个进程环境下的并发运行，如同于进程在同一个电脑下的并发运行。所以线程有时也称作</span><strong><span>lightweight processes</span></strong><span>，而</span><strong><span>multithreading</span></strong><span>也被用来描述允许多个线程在同一个进程的情况。CPU在多线程中切换，实现了并行的假象。</span></p><p><strong><span>线程状态</span></strong><span>：running, blocked, ready, terminated。与进程一致。</span></p><p><strong><span>线程引入的新的问题</span></strong><span>：</span></p><ul><li><span>时钟中断驱动了进程之间的调度，但是线程没有时钟中断，如何进行调度呢？我们可以用</span><code>thread_yield</code><span>让线程主动释放CPU资源。</span></li><li><span>给编程模型引入了更多复杂性。譬如</span><code>fork</code><span>一个多线程的进程，是不是要</span><code>fork</code><span>所有线程呢？如果不</span><code>fork</code><span>所有线程，那么子进程可能无法正常工作。如果</span><code>fork</code><span>了所有进程，如果父子线程都在等待数据，当一个数据来时，哪个线程获得数据呢？</span></li><li><span>竞态更容易在多线程中产生。</span></li></ul><h4 id='223-posix-threads'><span>2.2.3 POSIX Threads</span></h4><p><span>本书并没有详细介绍函数原型，只是给出了常见pthread函数：</span></p><figure><table><thead><tr><th><span>Thread call</span></th><th><span>Description</span></th></tr></thead><tbody><tr><td><span>Pthread_create</span></td><td><span>Create a new thread</span></td></tr><tr><td><span>Pthread_exit</span></td><td><span>Terminate the calling thread</span></td></tr><tr><td><span>Pthread_join</span></td><td><span>Wait for a specific thread to exit</span></td></tr><tr><td><span>Pthread_yield</span></td><td><span>Release the CPU to let another thread run</span></td></tr><tr><td><span>Pthread_attr_init</span></td><td><span>Create and initialize a thread&#39;s attribute structure</span></td></tr><tr><td><span>Pthread_attr_destory</span></td><td><span>Remove a thread&#39;s attribute structure</span></td></tr></tbody></table></figure><p><span>一些说明：</span></p><ul><li><span>Pthread有自己的标识符TID，一些寄存器（包括了PC），一些存在结构体中的性质（栈大小、调度参数比如优先度等）。</span></li><li><span>pthread_join会阻塞调用线程，直到一个特定的进程退出。</span></li><li><span>pthread_yield主动放弃CPU，而进程中没有这种操作，是因为进程默认是fiercely competitive的，每个进程都渴望得到所有的CPU资源。</span></li><li><span>pthread_attr_destory虽然删去了性质，但是线程还是可以继续执行的。</span></li></ul><h4 id='224-在用户空间实现线程'><span>2.2.4 在用户空间实现线程</span></h4><p><span>接下来要讨论线程的实现，分别是在用户空间和内核的两种实现，当然混合实现也是可能的。这一块内容和《操作系统概念》（恐龙书）似乎是有偏差的，我尽可能都cover到。</span></p><p><span>根据操作系统内核是否对线程可感知，可以把线程分为</span><strong><span>用户级线程（user-level thread）</span></strong><span>和</span><strong><span>内核级线程（kernel-level thread）</span></strong><span>。如下图所示：</span></p><p><img src="./img/image-20220312132730063.png" alt="image-20220312132730063" style="zoom:15%;" /></p><p><span>在开始前应当区分用户级线程、内核级线程、用户线程和内核线程。用户级和内核级线程是强调管理者是在用户空间还是内核空间；而用户和内核线程是指线程所运行的地址空间是用户空间还是内核空间。所有的用户级线程都是用户线程；而内核级线程既可以是用户线程也可以是内核线程，取决于运行的地址空间。个人觉得《现代操作系统》在混用内核线程和内核级线程。</span></p><p><span>本节先讲述用户级线程</span></p><p><span>用户级线程完全在用户空间实现，内核意识不到用户级线程的实现。内核中维护进程表，来调度每个进程。进程由</span><strong><span>运行时系统（run-time system）</span></strong><span>和线程组成。运行时系统负责管理该进程中的所有线程。运行时系统有线程表，存了PC、寄存器、栈指针、状态等。</span></p><p><strong><span>优势</span></strong><span>：</span></p><ul><li><span>在不支持线程的操作系统上实现线程</span></li><li><span>切换线程不需要系统调用，速度快</span></li><li><span>定制每个进程中线程的调度方案</span></li><li><span>规模更好，内核级线程在内核需要表格空间和栈空间，在线程数量过大时这可能会是个问题。</span></li></ul><p><strong><span>劣势</span></strong><span>：</span></p><ul><li><span>一个线程如果在系统调用中被阻塞了，整个进程都会被阻塞，即便其他线程还可以运行。我们可以要求非阻塞系统调用，但是这会牵一发而动全身。更好的解决办法是用</span><code>select</code><span>系统调用：在</span><code>read</code><span>前先用</span><code>select</code><span>判断会不会产生阻塞，如果会的话就不</span><code>read</code><span>了，而是去运行其他线程。</span></li><li><span>调度有困难。由于时钟中断不控制线程之间的调度，除非运行的线程主动放弃CPU并交还给运行时系统，不然其他线程只有等上下文切换到这个进程、运行时系统重新获得控制后，才有可能执行。</span></li><li><span>多核下，一个进程的多个线程无法并行执行。</span></li></ul><h4 id='225-在内核中实现线程'><span>2.2.5 在内核中实现线程</span></h4><p><span>内核级线程是直接由操作系统内核支持的线程。内核不仅维护了进程表还维护了线程表，内核通过操纵调度器对线程进行调度。不再有运行时系统。</span></p><p><strong><span>优势</span></strong><span>：</span></p><ul><li><span>线程是最小调度单位，而不是进程。解决了阻塞和调度困难。也就是说一个线程阻塞不会影响到同一个进程中的其他线程，时钟中断也可以控制线程之间的调度。</span></li></ul><p><strong><span>劣势</span></strong><span>：</span></p><ul><li><span>耗时相对长：使用系统调用来创建、销毁、阻塞线程。一个应对小技巧是：删除线程只是标记一下这个线程不能运行，创建线程可以重新激活被标记不可运行的程序。</span></li></ul><p><strong><span>悬而未决的问题</span></strong><span>：</span></p><ul><li><code>fork</code><span>多线程进程，到底是</span><code>fork</code><span>全部线程呢，还是</span><code>fork</code><span>调用者这个线程呢？</span></li><li><span>signal传递给进程，那哪个线程接受呢？或许所有线程要在进程那里注册一下自己想要收到的信号，但是两个线程注册了同一个信号，那这个信号来了后，到底是给谁的呢？</span></li></ul><h4 id='226-混合实现'><span>2.2.6 混合实现</span></h4><p><span>结合使用用户级线程和内核级线程，将多个用户级线程连接到内核级线程，而内核只知道内核级线程。由内核级线程管理用户级线程。</span></p><p><span>这里补充一些恐龙书上的内容。</span></p><p><strong><span>轻量级进程（lightweight process，LWP）</span></strong><span>运行在用户空间，共享进程地址空间和系统资源，并与内核进程一一对应，但可以对应多个用户线程。而《现代操作系统》认为轻量级进程就是线程，两者有出入。</span></p><p><img src="./img/image-20220312155341604.png" alt="image-20220312155341604" style="zoom:50%;" /></p><p><span>连接用户线程和内核线程由四种常见连接方案：</span></p><ul><li><span>多对一：很像是2.2.4用户级线程的实现，但是注意到严格来说，2.2.4的内核是没有线程概念的。优劣和2.2.4一致。</span></li><li><span>一对一：一个用户线程映射一个内核线程，有点轻量级进程的感觉。并发更好，但是会占据太多内核的空间。</span></li><li><span>多对多</span></li><li><span>两级：联合使用一对一和多对多</span></li></ul><p><span>个人觉得《现代操作系统》和《操作系统概念》是从两个角度看待线程实现的。。。让人头大。</span></p><p><em><span>2.2.7 Scheduler Activations, 2.2.8 Pop-Up Threads, 2.2.9 Making Single-Threaded Code Multithreaded姑且没有整理</span></em></p><h3 id='23-进程间通信'><span>2.3 进程间通信</span></h3><p><span>现在考虑进程通信问题——</span><strong><span>InterProcess Communication (IPC)</span></strong><span>. 主要有三个问题：</span></p><ol start='' ><li><span>how one process can pass information to another</span></li><li><span>make sure two or more processes do not get in each other&#39;s way 互斥</span></li><li><span>concern proper sequencing when depencies are present 同步</span></li></ol><p><span>对于线程来说，最后两个问题也是普遍有效的。当然第一个问题对于不同进程中的线程也是有效的。接下来我们讨论的大部分是进程，但是记住问题和解决办法对线程来说也是一样的。</span></p><h4 id='231-竞态'><span>2.3.1 竞态</span></h4><p><span>以</span><strong><span>打印后台处理服务（print spooler）</span></strong><span>为例说明。当一个进程想要打印文件时，它会把文件名字写入</span><strong><span>spooler directory</span></strong><span>。而</span><strong><span>打印机守护进程（printer daemon）</span></strong><span>则周期性地查看有没有文件需要打印，如果有的话就将其打印、并把文件名字从spooler directory中移除。</span></p><p><span>想象spooler directory由许多个槽（slot）组成，并以0,1,2,...编号，每个槽能够放一个文件名字。再想象有两个所有进程共享的变量：out指向下一个要打印的文件，in指向下一个空的槽。现在out=4，in=7。</span></p><p><strong><span>竞态（race conditions）</span></strong><span>可能这样产生：进程A读取</span><code>in=7</code><span>并存到局部变量，在将想要打印的文件名字写入7号槽之前，被进程B抢占。进程B也读取</span><code>in=7</code><span>，把想要打印的文件名字写入7号槽，并把in更新为8。一段时间后，进程A重新运行，从局部变量内读取7，将内容写入7号槽，覆盖掉了进程B的，并把in更新为8。这样进程B的打印内容就永远丢失了。</span></p><p><span>多个进程同时读或者同时写共享的数据，就会产生竞态。随着多核带来的并行性提升，竞态变得愈发常见。</span></p><h4 id='232-临界区'><span>2.3.2 临界区</span></h4><p><span>避免竞态的关键在于只允许一个进程读写进程共享的数据。这就是所谓的</span><strong><span>互斥（mutual exclusion）</span></strong><span>。而程序中访问共享数据的部分称为</span><strong><span>临界区（critical region/section）</span></strong><span>。于是，避免竞态就是避免两个进程同时进入临界区。提出四点要求：</span></p><ol start='' ><li><span>No two processes may be simultaneously inside their critical regions.</span></li><li><span>No assumptions may be made about speeds or the number of CPUs.</span></li><li><span>No process running outside its critical region may block any process.</span></li><li><span>No process should have to wait forever to enter its critical region.</span></li></ol><h4 id='233-忙等实现互斥'><span>2.3.3 忙等实现互斥</span></h4><p><span>在考虑忙等之前，先看看其他的一些想法。</span></p><p><span>1）</span><strong><span>禁用中断</span></strong></p><p><span>我们知道只有当中断时，CPU才会调度。那么当一个进程进入临界区的时候，禁用所有中断，再在退出临界区后，恢复中断。这样就实现了互斥。该方法的劣势有：</span></p><ul><li><span>给用户进程禁用中断的能力是不明智的。用户如果故意使他的进程永远在临界区，那么中断不再会发生，系统将会崩溃。不过话说回来，it is convenient for the kernel itself to diable interrupts for a few instructions while it is update variables or especially lists. 也就是内核可以这么做，但是用户不行。</span></li><li><span>禁用中断对于多核处理器失效。当一个CPU的中断被禁用，其他CPU还是可以进入临界区。</span></li></ul><p><span>2）</span><strong><span>Lock Variables</span></strong></p><p><span>有一个初始为0的共享变量。当它为0时，进程设置它为1，然后进入临界区；当它为1时，进程等待它变回0。可见0意味着没有进程在临界区，1意味着有。这个变量称为Lock variable。</span></p><p><span>但是这个方案不可行，有我们2.3.1讨论的打印机后台程序相同的毛病。当进程A读取lock，发现它是0，然而在设置为1之前被进程B抢占。进程B读取lock发现是0，设置为1后进入临界区。在B出来前，进程A再次运行，将lock设置为1，进入临界区。这样两个进程都在临界区里了。</span></p><p><span>3）</span><strong><span>忙等</span></strong></p><p><strong><span>忙等（busy waiting）</span></strong><span>指不断检查一个变量的值，直到一些特定的值出现。利用忙等实现的锁称为</span><strong><span>自旋锁（spin lock）</span></strong><span>。下面是一个有小问题但是整体可行的方案：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// process 0</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">while</span> (<span class="cm-atom">true</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span> (<span class="cm-variable">turn</span> <span class="cm-operator">!=</span> <span class="cm-number">0</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  ;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// enter when turn is 0</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">critical_region</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">turn</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">noncritical_region</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//process 1</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">while</span> (<span class="cm-atom">true</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">while</span> (<span class="cm-variable">turn</span> <span class="cm-operator">!=</span> <span class="cm-number">1</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  ;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">// enter when turn is 1</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">critical_region</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">turn</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">noncritical_region</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 408px;"></div><div class="CodeMirror-gutters" style="display: none; height: 408px;"></div></div></div></pre><p><span>这个方案默认了两个进程交替进入临界区。这会违背2.3.2提出要求的第三条：一个不在临界区运行的进程不应该阻塞其他进程。现考虑进程0运行快于进程1。进程1设置完turn为0后进入非临界区，进程0则成功进入临界区、将turn设置为1、进入非临界区，在进程0开始下一次循环时，却会被while循环拒之门外。而此时进程1还在非临界区慢慢运行。这样即便进程1不在临界区，但是进程0却进不去临界区。</span></p><p><span>此外，忙等自然会产生CPU时间浪费。还有，每一行代码应该都是看作是原子的。</span></p><p><span>4）</span><strong><span>Peterson&#39;s Solution</span></strong></p><p><span>1981年，G. L. Peterson提出了一个简单的方案，来解决两进程须交替进入临界区的问题。代码为：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-variable">turn</span>;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-variable">interested</span>[<span class="cm-number">2</span>]; <span class="cm-comment">// initially 0</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// process is 0 or 1</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">enter_region</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">process</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable-3">int</span> <span class="cm-variable">other</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> <span class="cm-operator">-</span> <span class="cm-variable">process</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">interested</span>[<span class="cm-variable">process</span>] <span class="cm-operator">=</span> <span class="cm-atom">true</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">turn</span> <span class="cm-operator">=</span> <span class="cm-variable">process</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span> (<span class="cm-variable">turn</span> <span class="cm-operator">==</span> <span class="cm-variable">process</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable">interested</span>[<span class="cm-variable">other</span>] <span class="cm-operator">==</span> <span class="cm-atom">true</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  ;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">leave_region</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">process</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">interested</span>[<span class="cm-variable">process</span>] <span class="cm-operator">=</span> <span class="cm-atom">false</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 295px;"></div><div class="CodeMirror-gutters" style="display: none; height: 295px;"></div></div></div></pre><p><span>进程</span><code>i(0 or 1)</code><span>进入临界区前调用</span><code>enter_region(i)</code><span>，退出临界区调用</span><code>leave_region(i)</code><span>。对于方案3中“一个不在临界区运行的进程不应该阻塞其他进程“的解决是显然的：退出后interested会变成false，while循环不再会将另一个进程拒之门外。</span></p><p><span>现在考虑两个进程几乎同时调用</span><code>enter_region</code><span>，两者都写入了共享变量</span><code>turn</code><span>，但是第一个写的会被覆盖。比如进程1覆盖了进程0的，现在turn为1。那么进程0将成功进入临界区，进程1则被自旋锁挡住了，直到进程0退出临界区、不再interested。</span></p><p><span>5）</span><strong><span>TSL指令</span></strong></p><p><span>之前讨论的方案2、3、4皆为软件实现，接下来我们讨论一个需要硬件支持的方案：</span><strong><span>测试并设置（Test and Set)</span></strong><span>。指令形式为：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="assembly"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="assembly"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">TSL</span> <span class="cm-keyword">RX</span>,LOCK</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;"></div><div class="CodeMirror-gutters" style="display: none; height: 23px;"></div></div></div></pre><p><span>将LOCK地址的值存到寄存器RX中，并存储一个非零的数到LOCK地址。并且TSL（Test and Set Lock）是一个原子的指令。用c描述为：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// run automatically</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-def">TestAndSet</span> (<span class="cm-variable-3">int</span> <span class="cm-variable-3">*</span><span class="cm-variable">old_ptr</span>, <span class="cm-variable-3">int</span> <span class="cm-variable">new</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable-3">int</span> <span class="cm-variable">old</span> <span class="cm-operator">=</span> <span class="cm-operator">*</span><span class="cm-variable">old_ptr</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-operator">*</span><span class="cm-variable">old_ptr</span> <span class="cm-operator">=</span> <span class="cm-variable">new</span>; <span class="cm-comment">// store a new value</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">return</span> <span class="cm-variable">old</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 136px;"></div><div class="CodeMirror-gutters" style="display: none; height: 136px;"></div></div></div></pre><p><span>不同于方案1禁用中断，TSL原子性是通过锁住内存总线而实现的。除了调用TSL的CPU外，其他CPU都无法访问内存。这种实现在多核处理器下能够正确运行，而方案1禁用中断会在多核处理器下失效。利用TSL指令我们可以这样实现自旋锁：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="assembly"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="assembly"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tag">enter_region:</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">TSL</span> <span class="cm-keyword">REGISTER</span>,LOCK  <span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-comment"># copy lock to register and set lock to 1</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">CMP</span> <span class="cm-keyword">REGISTER</span>,0<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># was lock zero?</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">JNE</span> <span class="cm-keyword">enter_region</span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># if it was not zero, lock was set, so loop</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">RET</span><span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># return to caller, critical region entered</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tag">leave_region:</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">MOVE</span> <span class="cm-keyword">LOCK</span>,0<span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># store a 0 in lock</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">RET</span><span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># return to caller</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 204px;"></div><div class="CodeMirror-gutters" style="display: none; height: 204px;"></div></div></div></pre><p><span>当进程进入临界区前调用</span><code>enter_region</code><span>，退出临界区调用</span><code>leave_region</code><span>。与测试并设置类似的是</span><strong><span>原子交换指令XCHG</span></strong><span>。x86就是使用了XCHG指令。利用XCHG指令我们可以这样实现自旋锁：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="assembly"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="assembly"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tag">enter_region:</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">MOVE</span> <span class="cm-keyword">REGISTER</span>,1<span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># put q in the register</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">XCHG</span> <span class="cm-keyword">REGISTER</span>,LOCK<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-comment"># swap the contents of the register and lock atomatically</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">CMP</span> <span class="cm-keyword">REGISTER</span>,0<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># was lock 0?</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">JNE</span> <span class="cm-keyword">enter_region</span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># if it was non zero, lock was set, so loop</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">RET</span><span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># return to caller, critical region entered</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" class="cm-tab-wrap-hack" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tag">leave_region:</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">MOVE</span> <span class="cm-keyword">LOCK</span>,0<span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># store a 0 in lock</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">RET</span><span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># return to caller</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 227px;"></div><div class="CodeMirror-gutters" style="display: none; height: 227px;"></div></div></div></pre><p><span>此外，在ostep上有更多的硬件原语：compare-and-exchange，load-linked and store-conditional，fetch-and-add。这里不再展开了。</span></p><h4 id='234-睡眠和唤醒'><span>2.3.4 睡眠和唤醒</span></h4><p><span>2.3.3节讨论的可行方案都是采用了忙等。忙等不仅仅会浪费CPU时间，它还会产生其他问题。考虑一个高优先级的进程H和低优先级的进程L，调度方案是优先级调度，也就是只要当H在ready态时，就让H运行。现在H阻塞，L运行并且进入了临界区；I/O操作结束后H重新回到ready态，L被H抢占；H也想进入临界区，于是开始忙等；然而L不会被调度，因为H在运行。最终H永远陷入了循环，L却不会被调度。这样子的情况有时被称为</span><strong><span>priority inversion problem</span></strong><span>.</span></p><p><span>接下来我们来讨论一对系统调用：</span><strong><span>sleep</span></strong><span>和</span><strong><span>wakeup</span></strong><span>。</span><code>sleep()</code><span>使调用者阻塞，直到另一个进程唤醒它。</span><code>wakeup(process)</code><span>则唤醒目标进程。下面我多次说的“睡觉”其实就可以理解为阻塞。</span></p><p><span>利用sleep和wakeup我们来解决</span><strong><span>生产者消费者问题</span></strong><span>（</span><strong><span>producer-consumer problem</span></strong><span>, also known as the </span><strong><span>bounded-buffer problem</span></strong><span>）。为了简化问题，我们只考虑两个进程共享一个大小固定的buffer。其中一个进程把内容写进buffer，另一个进程读取buffer中的内容。想法很简单，当生产者想要写入满的buffer，就让它睡觉，直到消费者移除了buffer中的一些内容；当消费者想要消费空的buffer，就让它睡觉，直到生产者写入了buffer。于是我们有如下代码：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//producer-consumer with a fatal race condition</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define N 100</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-variable">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">producer</span>(<span class="cm-variable-3">void</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">item</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span> (<span class="cm-atom">true</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">item</span> <span class="cm-operator">=</span> <span class="cm-variable">produce_item</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">count</span> <span class="cm-operator">==</span> <span class="cm-variable">N</span>) <span class="cm-variable">sleep</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">insert_item</span>(<span class="cm-variable">item</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">count</span><span class="cm-operator">++</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">count</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) <span class="cm-variable">wakeup</span>(<span class="cm-variable">consumer</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">consumer</span>(<span class="cm-variable-3">void</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable-3">int</span> <span class="cm-variable">item</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span> (<span class="cm-atom">true</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">// if preempted before sleep()</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">count</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) <span class="cm-variable">sleep</span>(); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">item</span> <span class="cm-operator">=</span> <span class="cm-variable">remove_item</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">count</span><span class="cm-operator">--</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">count</span> <span class="cm-operator">==</span> <span class="cm-variable">N</span><span class="cm-operator">-</span><span class="cm-number">1</span>) <span class="cm-variable">wakeup</span>(<span class="cm-variable">producer</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">consume_item</span>(<span class="cm-variable">item</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 589px;"></div><div class="CodeMirror-gutters" style="display: none; height: 589px;"></div></div></div></pre><p><span>乍一看没什么问题，生产者在空buffer里insert_item后就唤醒消费者，生产者发现buffer满后就睡大觉；消费者也是类似。然而还是会产生竞态。考虑在buffer为空时，消费者运行到</span><code>if (count == 0) sleep();</code><span>，在执行</span><code>sleep()</code><span>前被抢占，但是已经读取了</span><code>count</code><span>来看看它是否为0。此时生产者开始运行，写入buffer，并在</span><code>if (count == 1) wakeup(consumer);</code><span>唤醒消费者，但是注意到此时消费者并没有睡觉，于是这个唤醒信号将被丢弃。就这样生产者一直运行直到buffer满了，调用sleep睡大觉。消费者重新运行后，发现它之前读的</span><code>count</code><span>是0，于是也调用sleep睡觉觉。就这样，生产者和消费者一起睡觉去了。类似地，buffer满时，生产者在执行</span><code>sleep()</code><span>前被抢占，也会产生该问题。这种问题有时称为</span><strong><span>唤醒/等待竞争（wakeup/waiting race）</span></strong><span>。</span></p><p><span>问题的关键是wakeup信号传给一个马上要睡觉但是没有睡觉的进程会丢失。一个快速修复是利用一个</span><strong><span>wakeup waiting bit</span></strong><span>（个人认为是进程共享的）。当唤醒信号传到一个醒着的进程，那么设置</span><code>bit = 1</code><span>；当一个进程要睡觉，但是此时</span><code>bit == 1</code><span>，那么设置</span><code>bit = 0</code><span>，并且不睡觉。此外，书上提及&quot;The consumer clears the wakeup waiting bit in every iteration of the loop&quot;可能是为了解决刚开始两进程都未阻塞，但是生产者给了消费者唤醒信号，这个信号确实应该被丢弃。</span></p><p><span>一位wakeup waiting bit可以解决上述问题，但是我们可以构造一个三个进程的例子，来说明一位是不足够的。可以增加位数，但是问题还是在那里。</span></p><h4 id='235-信号量'><span>2.3.5 信号量</span></h4><p><span>1965年，E. W. Dijkstra提议用一个整数来记录wakeup数。他引入了一个新的变量类型，被称做</span><strong><span>信号量（semaphore）</span></strong><span>。不同实现下，信号量的语义略有不同，ostep上认为信号量可以是负的，本书采用的是POSIX的语义，信号量是非负的。</span></p><p><span>信号量有两个重要的相关的原子操作：</span><strong><span>down</span></strong><span>和</span><strong><span>up</span></strong><span>。最初Dijkstra提出来的时候是P和V，但是这是源于荷兰语，我们就不采用了。</span></p><ul><li><strong><span>down</span></strong><span>：若信号量大于0，减一后返回。若信号量等于0，则sleep，且认为down没有执行完，当被唤醒时，将信号量减一。</span></li><li><strong><span>up</span></strong><span>：将信号量加一，如果有进程因为这个信号量睡觉了，则随机唤醒其中的一个，让它继续执行down（这样信号量又回到了0，但是睡觉的进程少了一个）。个人认为随机唤醒其中的一个，只是把它加入等待队列，并不是立刻执行，这样信号量会是1，可以其他进程率先获得这个锁，而不是那个刚刚唤醒的进程。</span></li></ul><p><span>通常down和up是当作系统调用实现的。操作系统在测试、更新信号量以及让进程睡觉时，短暂地禁用所有的中断。由于这些操作很快，只需几步完成，禁用中断不会造成什么问题。在多核情况下，需利用TSL或XCHG指令来保证同时只有一个CPU能检查该信号量。（我觉得可以中断和TSL一同使用，中断保证单核下不调度，TSL实现自旋锁来保证其他CPU此时不能访问该信号量。书上并没有明确写这个意思。只是我的猜想。）</span></p><p><span>此外，还需要提及的是，吴帆PPT（可能包括恐龙书）把</span><code>down(&amp;semaphore)</code><span>替换为</span><code>wait(semaphore)</code><span>，把</span><code>up(&amp;semaphore)</code><span>替换为</span><code>signal(semaphore)</code></p><p><strong><span>利用信号量解决生产者消费者问题</span></strong></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// The producer-consumer problem using semaphores</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define N 100</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">typedef</span> <span class="cm-variable-3">int</span> <span class="cm-variable">semaphore</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">mutex</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>; <span class="cm-comment">//controls access to critical region</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">empty</span> <span class="cm-operator">=</span> <span class="cm-variable">N</span>; <span class="cm-comment">//counts empty buffer slots</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">full</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; &nbsp;<span class="cm-comment">//counts full buffer slots</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">producer</span>() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable-3">int</span> <span class="cm-variable">item</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span> (<span class="cm-atom">true</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">item</span> <span class="cm-operator">=</span> <span class="cm-variable">produce_item</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">//the following two down cannot reverse order</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">empty</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">insert_item</span>(<span class="cm-variable">item</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">full</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">consumer</span>() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">item</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span> (<span class="cm-atom">true</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">full</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">item</span> <span class="cm-operator">=</span> <span class="cm-variable">remove_item</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">empty</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">consume_item</span>(<span class="cm-variable">item</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 657px;"></div><div class="CodeMirror-gutters" style="display: none; height: 657px;"></div></div></div></pre><p><span>这里三个信号量体现了信号量的两个用途：</span><strong><span>同步（synchronization）</span></strong><span>和</span><strong><span>互斥（mutal exclusion）</span></strong><span>。其中</span><code>empty</code><span>和</span><code>full</code><span>保证了一些特定的事件顺序发生或不发生，这便是同步。而</span><code>mutex</code><span>保证了至多一个进程能够进入临界区，这便是互斥。此外，像</span><code>mutex</code><span>这样/初始化为1/并且用来保证/两个其以上进程/至多只有一个能够同时进入临界区/的/信号量，被称做</span><strong><span>二值信号量（binary semaphore）</span></strong><span>。</span></p><p><span>在2.1.6节中我们曾讨论过中断发生的一个基本流程。在使用信号量的系统中，可以用信号量来隐藏中断。将初始值为0的信号量和I/O设备一一关联。当有进程使用I/O设备时，该进程does a down on the associated semaphore，于是就阻塞了。当I/O设备工作完成后，发来中断，中断处理程序则对相关联的信号量进行up操作，于是该进程又回到了ready态。</span></p><p><span>producer函数里两个down不能交换顺序。否则，当buffer满时，生产者会带着锁阻塞，而消费者由于没有锁也会阻塞，最终使得两个进程全部阻塞，造成</span><strong><span>死锁（dead lock）</span></strong><span>。</span></p><h4 id='236-互斥量'><span>2.3.6 互斥量</span></h4><p><span>当信号量的计数功能不再需要，我们可以用一个简化的版本，称为</span><strong><span>互斥量（mutex）</span></strong><span>。顾名思义，互斥量用来实现互斥。它是一个共享的变量，有两个状态：unlocked or locked。因此只需要一位就可以表示了，但是通常我们用整型来表示互斥量。0表示unclocked，其他值表示clocked。我们将在线程的背景下讨论互斥量。</span></p><p><span>当一个线程想要进入临界区时，调用</span><code>mutex_lock</code><span>。如果该互斥量已经locked了，调用线程将会被阻塞，直到拥有锁的线程调用</span><code>mutex_unlock</code><span>释放锁。如果多个锁被这个互斥量阻塞了，那么其中一个会被随机选中并获得锁。下面是用户级线程的</span><code>mutex_lock</code><span>和</span><code>mutex_unlock</code><span>的实现：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="assembly"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="assembly"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">mutex_lock：</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">TSL</span> <span class="cm-keyword">REGISTER</span>，MUTEX <span class="cm-comment"># copy mutex to register and set mutex to 1</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">CMP</span> <span class="cm-keyword">REGISTER</span>，0</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">JZE</span> <span class="cm-keyword">ok</span><span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># if it was 0, mutex was unlocked, so return</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">CALL</span> <span class="cm-keyword">thread_yield</span> &nbsp; <span class="cm-comment"># give up CPU voluntarily</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">JMP</span> <span class="cm-keyword">mutex_lock</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tag">ok:</span> <span class="cm-keyword">ret</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tag">mutex_unclok:</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">MOVE</span> <span class="cm-keyword">MUTEX</span>,0</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">RET</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 249px;"></div><div class="CodeMirror-gutters" style="display: none; height: 249px;"></div></div></div></pre><p><span>注意到</span><code>thread_yield</code><span>主动放弃CPU，使上述实现没有忙等。此外</span><code>thread_yield</code><span> is just a call to the thread scheduler in user space， 所以</span><code>mutex_lock</code><span>和</span><code>mutex_unlock</code><span>无需陷入内核，全部在用户空间实现，十分快。</span></p><p><span>之前我们总是默认进程可以有共享的变量，但是又知道进程没有共享地址空间，那这一点是怎么实现的呢？有两个方案：</span></p><ul><li><span>将一些共享的数据结构比如信号量存在内核中，只能通过系统调用访问</span></li><li><span>大部分操作系统（包括UNIX和Windows）提供一些办法让进程之间共享部分部分地址空间。再不济的话，可以用一个共享的文件。</span></li></ul><p><strong><span>Futexes</span></strong></p><p><span>注意到之前提到的sleep、wakeup、down、up等指令都是系统调用，而总是陷入内核是相当昂贵的，并且其实很多时候并不会产生竞态。Linux采用了</span><strong><span>futex（fast user space mutex）</span></strong><span>来实现互斥同时避免不必要地陷入内核。futex包含两部分：内核服务和用户库。内核服务提供了等待队列允许多个进程等待一个锁。他们不会运行，直到内核显式取消它们的阻塞。大体思路是：在用户态使用原子操作，对持有锁的持有情况进行判断，如果锁可以占用，那么更新锁的状态并直接占用，不需要进入内核态，如果锁已经占用，则进入内核态挂起当前任务。书上也没有很详细，大体知道linux下的互斥锁是基于futex的就好了。</span></p><p><strong><span>Mutexes in Pthreads</span></strong></p><p><span>这里粗略介绍Pthread部分所提供的同步线程的函数。这些函数都保证其原子性。</span></p><figure><table><thead><tr><th><span>Thread call</span></th><th><span>Description</span></th></tr></thead><tbody><tr><td><span>Pthread_mutex_init</span></td><td><span>Create a mutex</span></td></tr><tr><td><span>Pthread_mutex_destroy</span></td><td><span>Destroy an existing mutex</span></td></tr><tr><td><span>Pthread_mutex_lock</span></td><td><span>Acquire a lock or block</span></td></tr><tr><td><span>Pthread_mutex_trylock</span></td><td><span>Acquire a lock or fail</span></td></tr><tr><td><span>Pthread_mutex_unlock</span></td><td><span>Release a lock</span></td></tr></tbody></table></figure><p><span>注意到</span><code>Pthread_mutex_lock</code><span>尝试获取锁，如果失败就会阻塞；</span><code>Pthread_mutex_trylock</code><span>尝试获取锁，失败了返回不为0的错误值，不阻塞。</span></p><p><span>此外Pthread还提供</span><strong><span>条件变量（condition variable）</span></strong><span>。条件变量使得线程能因一些条件没有满足而阻塞。比如生产者消费者问题中，当我们发现buffer满了，可以利用条件变量来阻塞和之后唤醒线程。</span></p><figure><table><thead><tr><th><span>Thread call</span></th><th><span>Description</span></th></tr></thead><tbody><tr><td><span>Pthread_cond_init</span></td><td><span>Create a condition variable</span></td></tr><tr><td><span>Pthread_cond_destroy</span></td><td><span>Destroy a condition variable</span></td></tr><tr><td><span>Pthread_cond_wait</span></td><td><span>Block waiting for a signal</span></td></tr><tr><td><span>Pthread_cond_signal</span></td><td><span>Signal another thread and wake it up</span></td></tr><tr><td><span>Pthread_cond_broadcast</span></td><td><span>Signal multiple threads and wake all of them</span></td></tr></tbody></table></figure><p><span>互斥量和条件变量总是一起使用的。此外，信号传给一个没有线程等待的条件变量的话，这个信号会被简单地丢弃。这里再给出两点建议：</span></p><ul><li><strong><span>调用wait和signal时都要持有锁</span></strong><span>：调用wait时持有锁是语义要求，因为wait的职责是释放锁，并让调用线程睡觉，当线程被唤醒后，该线程会放到就绪队列，当它再次运行时，wait会重新获得锁，再返回调用者；而调用signal持有锁并不是严格需要，但为了生活简单，还是要持有锁。</span></li><li><strong><span>对条件变量使用while而不是if</span></strong><span>：检查条件变量时，while总是对的，if可能会对。</span></li></ul><p><span>下面是一个完成的利用线程解决生产者消费者问题的代码：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//using threads to solve the producer-consumer problem with a single buffer</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">//多值缓冲区可以看ostep30.2 P259</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#include &lt;stdio.h&gt;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#include &lt;pthread&gt;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define MAX 100000000</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">pthread_mutex_t</span> <span class="cm-variable">the_mutex</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">pthread_cond_t</span> <span class="cm-variable">condc</span>, <span class="cm-variable">condp</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-variable">buffer</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-variable-3">*</span><span class="cm-def">producer</span>(<span class="cm-variable-3">void</span> <span class="cm-variable-3">*</span><span class="cm-variable">ptr</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">i</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">for</span> (<span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">MAX</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">pthread_mutex_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">the_mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">//如果buffer非0，wait</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">while</span>(<span class="cm-variable">buffer</span><span class="cm-operator">!=</span><span class="cm-number">0</span>)<span class="cm-variable">pthread_cond_wait</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">condp</span>,<span class="cm-operator">&amp;</span><span class="cm-variable">the_mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">buffer</span> <span class="cm-operator">=</span> <span class="cm-variable">i</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">pthread_cond_signal</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">condc</span>);<span class="cm-comment">//唤醒消费者</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">pthread_mutex_unlock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">the_mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_exit</span>(<span class="cm-number">0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-variable-3">*</span><span class="cm-def">consumer</span>(<span class="cm-variable-3">void</span> <span class="cm-variable-3">*</span><span class="cm-variable">ptr</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable-3">int</span> <span class="cm-variable">i</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">for</span> (<span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">MAX</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">pthread_mutex_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">the_mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-comment">//如果buffer为0，wait</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">while</span>(<span class="cm-variable">buffer</span><span class="cm-operator">==</span><span class="cm-number">0</span>)<span class="cm-variable">pthread_cond_wait</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">condc</span>,<span class="cm-operator">&amp;</span><span class="cm-variable">the_mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">buffer</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">pthread_cond_signal</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">condp</span>);<span class="cm-comment">//唤醒生产者</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">pthread_mutex_unlock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">the_mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_exit</span>(<span class="cm-number">0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-def">main</span>()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">pthread_t</span> <span class="cm-variable">pro</span>, <span class="cm-variable">con</span>;<span class="cm-comment">//两个线程</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_mutex_init</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">the_mutex</span>,<span class="cm-variable">NULL</span>);<span class="cm-comment">//初始化互斥量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_cond_init</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">condc</span>,<span class="cm-variable">NULL</span>);<span class="cm-comment">//初始化条件变量condc</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_cond_init</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">condp</span>,<span class="cm-variable">NULL</span>);<span class="cm-comment">//初始化条件变量condp</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_create</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">con</span>,<span class="cm-variable">NULL</span>,<span class="cm-variable">consumer</span>,<span class="cm-variable">NULL</span>);<span class="cm-comment">//创建con线程</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_create</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">pro</span>,<span class="cm-variable">NULL</span>,<span class="cm-variable">producer</span>,<span class="cm-variable">NULL</span>);<span class="cm-comment">//创建pro线程</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_join</span>(<span class="cm-variable">pro</span>,<span class="cm-variable">NULL</span>);<span class="cm-comment">//等待con线程结束</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_join</span>(<span class="cm-variable">con</span>,<span class="cm-variable">NULL</span>);<span class="cm-comment">//等待pro线程结束</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_cond_destroy</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">condc</span>);<span class="cm-comment">//摧毁条件变量condc</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_cond_destroy</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">condp</span>);<span class="cm-comment">//摧毁条件变量condp</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">pthread_mutex_destroy</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">the_mutex</span>);<span class="cm-comment">//摧毁互斥量</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 1133px;"></div><div class="CodeMirror-gutters" style="display: none; height: 1133px;"></div></div></div></pre><h4 id='237-管程'><span>2.3.7 管程</span></h4><p><span>Using semaphores and mutexes is by no means easy. To make it easier to write correct programs, Brinch Hansen (1973) and Hoare (1974) proposed a higher-level synchronization primitive called a </span><strong><span>monitor (管程)</span></strong><span>. A monitor is a collection of procedures, variables, and data structures that are grouped together in a special kind of module or package, much like class in cpp. </span></p><p><strong><span>Monitors have an important property: only one process can be active in a monitor at any instant</span></strong><span>. If there is a process using the monitor, then the calling process will be suspended until that process has left. Otherwise, it can enter the monitor.</span></p><p><span>Monitors are a programming-language construct, so the compiler knows they are special. It is up to the compiler to implement mutual exclusion on monitor entries, but a common way is to use a mutex or a binary semaphore. Because the compiler, not the programmer, is arranging for the mutual exclusion,  it is much less likely that something will go wrong.</span></p><p><span>However, mutual exclusion is not enough. We also need condition variables in monitor to block calling procedures when they cannot continue. As is mentioned earlier, </span><code>wait</code><span> is used to block a process and release its lock while </span><code>signal</code><span> is used to wake up a process and enable it to hold the previous lock again.</span></p><p><span>After doing a </span><code>signal</code><span> on a condition variable to wake up a sleeping partner, we need a rule to decide which one should be in the monitor. There are three proposals.</span></p><ul><li><span>Hoare: letting the newly awakened process run, suspending the other one</span></li><li><span>Brinch Hanse: the process which does the signal must exit the monitor immediately. In other words, a </span><code>signal</code><span> statement may appear only as the final statement in a monitor function.</span></li><li><span>letting the process which do that signal continue to run and allow the waiting process to start running only after the signaler has exited the monitor</span></li></ul><p><span>For simplicity, we will use Brinch Hanse&#39;s proposal. Here is a monitor example written in an imaginary language, Pidgin Cpp, by myself.</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c++" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c++"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">monitor</span> <span class="cm-variable">ProducerConsumer</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">private</span>:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">condition</span> <span class="cm-variable">full</span>, <span class="cm-variable">empty</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable-3">int</span> <span class="cm-variable">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">public</span>:</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable-3">void</span> <span class="cm-variable">insert</span>(<span class="cm-variable">item</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">if</span>(<span class="cm-variable">count</span> <span class="cm-operator">==</span> <span class="cm-variable">N</span>) <span class="cm-variable">wait</span>(<span class="cm-variable">full</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">insert_item</span>(<span class="cm-variable">item</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">count</span><span class="cm-operator">++</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span>(<span class="cm-variable">count</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) <span class="cm-variable">signal</span>(<span class="cm-variable">empty</span>); <span class="cm-comment">//signal is the final statement</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">item</span> <span class="cm-variable">remove</span>()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">if</span>(<span class="cm-variable">count</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) <span class="cm-variable">wait</span>(<span class="cm-variable">empty</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">item</span> <span class="cm-variable">remove</span> <span class="cm-operator">=</span> <span class="cm-variable">remove_item</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">count</span><span class="cm-operator">--</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span>(<span class="cm-variable">count</span> <span class="cm-operator">==</span> <span class="cm-variable">N</span><span class="cm-operator">-</span><span class="cm-number">1</span>) <span class="cm-variable">signal</span>(<span class="cm-variable">full</span>); <span class="cm-comment">//signal is the final statement</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return</span> <span class="cm-variable">remove</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">procedure</span> <span class="cm-variable">producer</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">while</span> (<span class="cm-atom">true</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">item</span> <span class="cm-variable">itm</span> <span class="cm-operator">=</span> <span class="cm-variable">produce_item</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">ProducerConsumer</span>.<span class="cm-variable">insert</span>(<span class="cm-variable">item</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">procedure</span> <span class="cm-variable">consumer</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">while</span> (<span class="cm-atom">true</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">item</span> <span class="cm-operator">=</span> <span class="cm-variable">ProducerConsumer</span>.<span class="cm-variable">remove</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">consume_item</span>(<span class="cm-variable">item</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 839px;"></div><div class="CodeMirror-gutters" style="display: none; height: 839px;"></div></div></div></pre><p><span>The code above really looks similar to </span><code>sleep</code><span> and </span><code>wakeup</code><span> in section 2.3.4, which we saw earlier had fatal race conditions. Well, it&#39;s right, but with one crucial difference: </span><code>sleep</code><span> and </span><code>wakeup</code><span> failed because while one process was trying to go to sleep, the other one was trying to wake it up. With monitors, that cannot happen, which is guaranteed by monitors&#39; automatic mutual exclusion.</span></p><p><span>Although c does not support monitors, some programming language support monitors. For example, by adding the keyword </span><code>synchronized</code><span> to a method declaration, Java guarantees that once any thread has started executing that method, no other thread will be allowed to start executing any synchronized method of that object. But I will not dive into Java too deep.</span></p><p><span>In conclusion, monitors are a programming-language concept, which makes parallel programming less error prone but gives a new request to programming language (support monitors and semaphores), compilers (arrange for mutual exclusion) and operating systems (support semaphores).</span></p><p><em><span>2.3.8 Message Passing，2.3.9 Barriers和2.3.10 Avoiding Locks: Read-Copy-Update没有整理</span></em></p><h3 id='24-调度'><span>2.4 调度</span></h3><p><span>虽然下面主要讨论进程之间的调度，但是它们也适用于线程。事实上你会发现这些算法只是个大体思路，究其细节还是挺模糊的。</span></p><h4 id='241-介绍'><span>2.4.1 介绍</span></h4><p><strong><span>一些术语：</span></strong></p><ul><li><strong><span>burst</span></strong><span>：运行时长。CPU burst，I/O burst</span></li><li><strong><span>compute-bound/CPU-bound</span></strong><span>：进程花大量时间在计算上，CPU burst相对较长。</span></li><li><strong><span>I/O-bound</span></strong><span>：进程花大部分时间在等待I/O上</span></li><li><span>A </span><strong><span>nonpreemptive</span></strong><span> (非抢占式) scheduling algorithm picks a process to run and then just lets it run until it blocks (either on I/O or waiting for another process) or voluntarily releases the CPU.</span></li><li><span>A </span><strong><span>preemptive</span></strong><span> (抢占式) scheduling algorithm picks a process and lets it run for a maximum of some fixed time. If it is still running at the end of the time interval, it is suspended and the scheduler picks another process to run. Doing preemptive scheduling requires having a clock interrupt occur at the end of the time intercal to give control of the CPU back to the scheduler.</span></li></ul><p><strong><span>何时调度：</span></strong></p><ul><li><span>创建新进程时</span></li><li><span>进程结束时</span></li><li><span>进程阻塞时</span></li><li><span>I/O中断时</span></li></ul><p><strong><span>目标</span></strong><span>：</span></p><ul><li><p><span>All systems</span></p><ul><li><strong><span>Fairness</span></strong><span>: giving each process a fair share of CPU</span></li><li><strong><span>Policy enforcement</span></strong><span>: seeing that stated policy is carried out</span></li><li><strong><span>Balance</span></strong><span>: keeping all parts of the system busy</span></li></ul></li><li><p><span>Batch systems</span></p><ul><li><strong><span>Throughput (吞吐量)</span></strong><span>: maximize jobs per hour</span></li><li><strong><span>Turnaround time (周转时间)</span></strong><span>: minimize time between submission and termination</span></li><li><strong><span>CPU utilization</span></strong><span>: keep the CPU busy all the time</span></li></ul></li><li><p><span>Interactive systems</span></p><ul><li><strong><span>Response time (响应时间)</span></strong><span>: the time between issuing a command and getting the result。也就是首次开始运行的时刻减去到达的时刻。</span></li><li><strong><span>Proportionality</span></strong><span>: meet users&#39; expectations</span></li></ul></li><li><p><span>Real-time systems</span></p><ul><li><strong><span>Meeting deadlines</span></strong><span>: avoid losing data</span></li><li><strong><span>Predictability</span></strong><span>: avoid quality degradation in multimedia systems (e.g. if the audio process runs too erratically, the sound quality will deteriorate rapidly)</span></li></ul></li></ul><p><span>恐龙书上还定义了</span><strong><span>Waiting time</span></strong><span>（等待时间）: 进程在就绪队列中等待调度的时间片总和</span></p><h4 id='242-批处理系统调度方案'><span>2.4.2 批处理系统调度方案</span></h4><p><strong><span>批处理系统（batch system）</span></strong><span>中没有用户着急地等待终端快速响应一个短请求。因此非抢占式的算法或者等待较长时间的抢占式算法通常可以接受。这减少了上下文切换，由此提升了性能。</span></p><p><strong><span>First-Come, First-Served (FCFS)</span></strong><span> </span></p><p><span>维护一个等待队列，CPU每次处理队首任务。当一个阻塞进程变回ready态时，它将放到队列末，如同一个新进程那样。</span></p><p><strong><span>优势</span></strong><span>：简单；先到先得很公平</span></p><p><strong><span>劣势</span></strong><span>：一些耗时较少的进程排在了耗时较长的进程之后，使得耗时较少的进程等待很长时间，也就是所谓的</span><strong><span>护航效应 (Convoy effect)</span></strong><span>。考虑一个每次运行1s的compute-bound进程和多个需要CPU时间极少但是要进行1000次磁盘访问的I/O-bound进程。这些I/O-bound的进程需要1000秒才能结束。如果时一个抢占式的调度器，每10毫秒抢占compute-bound进程，那么这些I/O-bound进程10秒就可以完成了。</span></p><p><strong><span>Shortest Job First (SJF) </span></strong></p><p><span>运行耗时最短的作业，直到它阻塞或者结束。若所有作业同时到达的话，SJF能达到最小的平均周转时间，可以认为是最优算法。SJF前提是假设了所有作业的运行时间已知。这对于每天做相同工作的批处理系统其实是可以做到的。</span></p><p><span>可以通过历史运行时间来估计下次运行时长。利用递推式</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="22.617ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 9996.9 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-18-TEX-I-1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path><path id="MJX-18-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-18-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-18-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-18-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-18-TEX-I-1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path><path id="MJX-18-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-18-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-18-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-18-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D70F" xlink:href="#MJX-18-TEX-I-1D70F"></use></g><g data-mml-node="TeXAtom" transform="translate(470,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-18-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(600,0)"><use data-c="2B" xlink:href="#MJX-18-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(1378,0)"><use data-c="31" xlink:href="#MJX-18-TEX-N-31"></use></g></g></g><g data-mml-node="mo" transform="translate(2125.7,0)"><use data-c="3D" xlink:href="#MJX-18-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(3181.5,0)"><use data-c="1D6FC" xlink:href="#MJX-18-TEX-I-1D6FC"></use></g><g data-mml-node="msub" transform="translate(3821.5,0)"><g data-mml-node="mi"><use data-c="1D461" xlink:href="#MJX-18-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-18-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(4912,0)"><use data-c="2B" xlink:href="#MJX-18-TEX-N-2B"></use></g><g data-mml-node="mo" transform="translate(5912.2,0)"><use data-c="28" xlink:href="#MJX-18-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(6301.2,0)"><use data-c="31" xlink:href="#MJX-18-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(7023.4,0)"><use data-c="2212" xlink:href="#MJX-18-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(8023.7,0)"><use data-c="1D6FC" xlink:href="#MJX-18-TEX-I-1D6FC"></use></g><g data-mml-node="mo" transform="translate(8663.7,0)"><use data-c="29" xlink:href="#MJX-18-TEX-N-29"></use></g><g data-mml-node="msub" transform="translate(9052.7,0)"><g data-mml-node="mi"><use data-c="1D70F" xlink:href="#MJX-18-TEX-I-1D70F"></use></g><g data-mml-node="mi" transform="translate(470,-150) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-18-TEX-I-1D45B"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>τ</mi><mrow data-mjx-texclass="ORD"><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>α</mi><msub><mi>t</mi><mi>n</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><msub><mi>τ</mi><mi>n</mi></msub></math></mjx-assistive-mml></mjx-container><script type="math/tex">\tau_{n+1}=\alpha t_n+(1-\alpha)\tau_n</script><span>来预测第</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 2322.4 748" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.186ex;"><defs><path id="MJX-19-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-19-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-19-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-19-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(822.2,0)"><use data-c="2B" xlink:href="#MJX-19-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(1822.4,0)"><use data-c="31" xlink:href="#MJX-19-TEX-N-31"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>+</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container><script type="math/tex">n+1</script><span>的时长。式中</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="1.728ex" height="1.332ex" role="img" focusable="false" viewBox="0 -431 764 588.8" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.357ex;"><defs><path id="MJX-20-TEX-I-1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path><path id="MJX-20-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D70F" xlink:href="#MJX-20-TEX-I-1D70F"></use></g><g data-mml-node="mi" transform="translate(470,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-20-TEX-I-1D456"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>τ</mi><mi>i</mi></msub></math></mjx-assistive-mml></mjx-container><script type="math/tex">\tau_i</script><span>是第</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.025ex;"><defs><path id="MJX-23-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-23-TEX-I-1D456"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math></mjx-assistive-mml></mjx-container><script type="math/tex">i</script><span>次预测时长，</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="1.556ex" height="1.773ex" role="img" focusable="false" viewBox="0 -626 688 783.8" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.357ex;"><defs><path id="MJX-22-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-22-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D461" xlink:href="#MJX-22-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-22-TEX-I-1D456"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>t</mi><mi>i</mi></msub></math></mjx-assistive-mml></mjx-container><script type="math/tex">t_i</script><span>是第</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewBox="0 -661 345 672" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.025ex;"><defs><path id="MJX-23-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-23-TEX-I-1D456"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>i</mi></math></mjx-assistive-mml></mjx-container><script type="math/tex">i</script><span>次真实时长。</span></p><p><span>虽然具有较好的周转时间，但是SJF在响应时间上表现的不好。</span><strong><span>饿死（starvation）</span></strong><span>——进程没有机会获取CPU资源，也可能会产生。</span></p><p><strong><span>Shortest remaining time next</span></strong></p><p><span>每次来进程时，看看我短还是当前进程剩余时间短，我短的话就抢占当前进程。同样的，该算法也假设所有作业的运行时间已知。</span></p><h4 id='243-交互式系统调度方案'><span>2.4.3 交互式系统调度方案</span></h4><p><span>交互式系统（interactive system）有猴急的用户。他们渴望立刻看到反应，所以响应时间很重要。交互式系统包括个人电脑、服务器等。</span></p><p><strong><span>Round-Robin (RR, 轮转)</span></strong></p><p><span>每个进程都被分配了一个时间间隔，称做</span><strong><span>调度量子（quantum）</span></strong><span>或者称做</span><strong><span>时间片（time-slice）</span></strong><span>。当进程运行时间超过了调度量子的话，进程将会被抢占而转为ready态。当然如果在调度量子结束前，进程已经阻塞或者结束了，CPU就会运行其他进程了。至于怎么选择其他进程，用FCFS等算法都行。</span></p><p><span>问题的关键在于如何选取调度量子的时长。如果时长过短会造成过频繁的进程切换从而降低CPU效率；时长过长会造成响应时间过长。一般来说在20～50毫秒为宜。</span></p><p><span>如果响应时间是我们的唯一指标，那么选取合适的调度量子时长，RR就会是非常好的调度方案。但是如果周转周期是我们的指标，RR是最糟糕的策略之一了。</span></p><p><strong><span>Priority Scheduling</span></strong></p><p><span>赋予每个进程优先级，每次运行优先等级最高的进程。为了防止高优先级的进程无限期地运行下去（产生其他进程</span><strong><span>饿死starvation</span></strong><span>），调度器可以在每个时钟中断降低正在运行进程的优先级（aging）。如果当前进程优先级低于下一个高优先级的进程的话，进程切换就会发生。我们还可以为每个进程分配调度量子，高优先级的进程用完调度量子后，就会运行次高优先度进程。</span></p><p><span>此外，We can group process into priority classes and use priority scheduling among the classes but round-robin scheduling within each class.</span></p><p><img src="./img/image-20220312211038965.png" alt="image-20220312211038965" style="zoom:20%;" /></p><p><strong><span>Multilevel Feedback Queue (MLFQ)</span></strong></p><p><span>很棒的一个调度方法。有以下几点要求：</span></p><ol start='' ><li><span>如果A的优先级&gt;B的优先级，运行A</span></li><li><span>如果A的优先级=B的优先级，轮转运行A和B</span></li><li><span>新工作放在最高优先级</span></li><li><span>一旦工作用完了其在某一层的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级</span></li><li><span>经过一段时间，将系统中所有工作重新放入最高优先级队列</span></li></ol><p><span>以上摘自ostep。恐龙书上则认为，有多个队列、每个队列有自己的调度算法、有情况使得进程降级和升级，就是多级反馈队列了。比如第一层和第二层采用不同调度量子的RR，第三层采用FCFS。本书没有提到该算法，倒是有个</span><strong><span>多级队列（Multiple Queue）</span></strong><span>，类似的也是每层采用不同的调度量子，跑完一层就去下一层。</span></p><p><strong><span>Lottery Scheduling</span></strong></p><p><span>之前的调度方案目标都是优化周转时间和响应时间，而这里我们调度程序的最终目标是：确保每个工作获得一定比例的CPU时间。这种算法称为</span><strong><span>proportional-share scheduling</span></strong><span>或者</span><strong><span>fair-share scheduling</span></strong><span>。其中最出名的是彩票调度了。</span></p><p><strong><span>彩票数（ticket）</span></strong><span>代表了进程占某个资源的份额。一个进程所拥有的彩票数占总彩票数的百分比为20%，那么它有20%的几率可以获得CPU。</span></p><p><span>彩票调度有一些有意思的机制：不同进程可以有不同彩票币种，允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己不同的工作，最后再由操作系统统一兑换为正确的全局彩票；彩票转让则允许一个进程临时把自己的彩票交给另一个进程，比如客户端阻塞后就把自己所有彩票转让给服务端，这样服务端有更大几率处理客户端的请求。</span></p><h4 id='244-实时系统调度方案'><span>2.4.4 实时系统调度方案</span></h4><p><span>并不是重点。个人觉得知道实时系统不一定是满足</span><strong><span>可调度的（schedulable）</span></strong><span>就行了。</span></p><h4 id='245-policy-versus-mechanism'><span>2.4.5 Policy Versus Mechanism</span></h4><p><span>mechanism是内核所定下来的，但是policy是可以由用户进程所设置的。意思就是说，有时父进程知道子进程的相对重要性，我就可以让父进程设置子进程的优先级，达到更好的调度效果。</span></p><h4 id='246-线程调度'><span>2.4.6 线程调度</span></h4><p><span>之前讨论的调度方案也适用于线程。无论是运行时系统调度用户级线程，还是内核调度内核级线程。但是内核级线程的调度会更倾向于同一个进程内线程的切换，而不是从一个进程的线程切换到另一个进程的线程，因为进程的上下文切换耗时长。线程级线程可以客制化调度方案，运行时系统可以知道每个线程具体是干啥的，这对于内核级线程是无法实现的。</span></p><h3 id='25-经典ipc问题'><span>2.5 经典IPC问题</span></h3><p><span>这里介绍</span><strong><span>哲学家就餐问题（dining philosophers problem）</span></strong><span>和</span><strong><span>读者写者问题（readers and writers problem）</span></strong><span>。</span></p><h4 id='251-哲学家就餐问题'><span>2.5.1 哲学家就餐问题</span></h4><p><span>几个哲学家围坐在圆桌旁。每个人面前放了一盆意大利面，面和面之间都放了一个叉子。哲学家有两个状态：思考和进食。由于哲学家思考得太累了，进食需要用两个叉子。于是哲学家会按照任意顺序先后拿起他左边和右边的叉子。吃一会儿后，哲学家放下叉子，继续思考。</span></p><p><span>如果不加锁的话，哲学家可能同时拿起他左边的叉子，这样所有人都拿不到右边的，造成了死锁。可能想到一个解决方案是：若哲学家发现只能拿起一个叉子时，就放下拿起的叉子，然后等待一个随机的时间，再尝试拿叉子。虽然大体可行，但是有可能算法失效（每次随机时间相同的话，虽然极小概率）。</span></p><p><span>利用信号量我们可以解决哲学家就餐问题：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define N 5 </span><span class="cm-comment">//the number of philosopher</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define LEFT (i+N-1)%N</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define RIGHT (i+1)%N</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define THINKING 0</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define HUNGRY 1</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define EATING 2</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">typedef</span> <span class="cm-variable-3">int</span> <span class="cm-variable">semaphore</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-variable">state</span>[<span class="cm-variable">N</span>];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">mutex</span><span class="cm-operator">=</span><span class="cm-number">1</span>; <span class="cm-comment">//binary semaphore</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">s</span>[<span class="cm-variable">N</span>]; <span class="cm-comment">//to block philosopher</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">philosopher</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">i</span>) <span class="cm-comment">//i:philosopher number, 0~N-1</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">while</span>(<span class="cm-atom">true</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">think</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">take_forks</span>(<span class="cm-variable">i</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">eat</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">put_forks</span>(<span class="cm-variable">i</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">take_forks</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">i</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">state</span>[<span class="cm-variable">i</span>]<span class="cm-operator">=</span><span class="cm-variable">HUNGRY</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">test</span>(<span class="cm-variable">i</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">s</span>[<span class="cm-variable">i</span>]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">put_forks</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">i</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">state</span>[<span class="cm-variable">i</span>] <span class="cm-operator">=</span> <span class="cm-variable">THINKING</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">test</span>(<span class="cm-variable">LEFT</span>); <span class="cm-comment">//see if left neighbor can now eat</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">test</span>(<span class="cm-variable">RIGHT</span>); <span class="cm-comment">//see if right neighbor can now eat</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">test</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">i</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">state</span>[<span class="cm-variable">i</span>]<span class="cm-operator">==</span><span class="cm-variable">HUNGRY</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable">state</span>[<span class="cm-variable">LEFT</span>]<span class="cm-operator">!=</span><span class="cm-variable">EATING</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable">state</span>[<span class="cm-variable">RIGHT</span>]<span class="cm-operator">!=</span><span class="cm-variable">EATING</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">state</span>[<span class="cm-variable">i</span>]<span class="cm-operator">=</span><span class="cm-variable">EATING</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">s</span>[<span class="cm-variable">i</span>]);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 975px;"></div><div class="CodeMirror-gutters" style="display: none; height: 975px;"></div></div></div></pre><h4 id='252-读者写者问题'><span>2.5.2 读者写者问题</span></h4><p><span>书上利用信号量给出了一个简单的思路：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">typedef</span> <span class="cm-variable-3">int</span> <span class="cm-variable">semaphore</span>;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">mutex</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">db</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-variable">rc</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">reader</span>()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span>(<span class="cm-atom">true</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">rc</span><span class="cm-operator">++</span>; <span class="cm-comment">//get exclusive access to rc</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">rc</span><span class="cm-operator">==</span><span class="cm-number">1</span>)<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">db</span>); <span class="cm-comment">//if there are readers, writers cannot write</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">read_data</span>(); <span class="cm-comment">//not locked, so multiple readers have access</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">rc</span><span class="cm-operator">--</span>; <span class="cm-comment">//get exclusive access to rc</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span>(<span class="cm-variable">rc</span><span class="cm-operator">==</span><span class="cm-number">0</span>)<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">db</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">mutex</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">use_data</span>(); <span class="cm-comment">//noncritical region</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">writer</span>()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-keyword">while</span>(<span class="cm-atom">true</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">think_up_data</span>(); <span class="cm-comment">//noncritical region</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">db</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">write_data</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">db</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 657px;"></div><div class="CodeMirror-gutters" style="display: none; height: 657px;"></div></div></div></pre><p><span>这个方案允许一个写者或者多个读者互斥进入。如果读者源源不断，那么写者可能永远也没有办法写入了。这个问题我们需要做一些修改，让写者有更高的优先度。这里不再展开。（事实上书上叫你看论文去）</span></p><hr /><div style="page-break-after: always;"></div> <h2 id='三内存管理'><span>三、内存管理</span></h2><p><span>本章讨论的是程序员视角下的</span><strong><span>主存（main memory）</span></strong><span>及其管理，至于存储器的组织结构（直接映射、组相连、SRAM、DRAM等）都是计算机组成关心的内容。内存和主存两个叫法个人觉得无需区分。</span></p><h3 id='31-无内存抽象'><span>3.1 无内存抽象</span></h3><p><span>早期计算机的所有程序直接访问物理地址，每个地址对应一个存储8位的cell。通常意义下，这种实现只允许同一时间内存中至多有一个用户程序，否则一个用户程序的读写操作可能会造成另一个用户程序的崩溃（不过接下来会看到一些解决方法）。但是计算机还需要操作系统吧，关于操作系统程序和用户程序在内存中的位置有各种约定：</span></p><ul><li><span>早期大型机和小型机：内存最上部分是用户程序，最下面是RAM中的操作系统程序</span></li><li><span>手持电脑和嵌入式系统：内存最上面是ROM中的操作系统，最下面是用户程序</span></li><li><span>早期个人电脑（譬如MS-DOS系统）：内存最上面是ROM中的BIOS（一些设备驱动等），中间是用户程序，最下面是RAM中的操作系统的其余部分</span></li></ul><p><span>同样的，用户程序的一些bug可能会导致操作系统崩溃。</span></p><p><span>想来点并行？不是不可能，用线程就好了，毕竟线程就是共享地址空间的。但是一方面用户原来想运行的是完全无关的多个程序，另一方面让不支持内存抽象的系统支持线程，可谓是天方夜谭。</span></p><p><strong><span>如何运行多个程序</span></strong></p><p><span>一个简单可行的想法是</span><strong><span>交换（swap）</span></strong><span>：把还没有运行完的整个用户程序从内存扔到磁盘，从磁盘加载另一个用户程序，从而实现了运行多个程序。</span></p><p><span>下面主要探讨第二个想法，被早期的IBM 360系统采用。CPU内部用寄存器为每个内存块（2KB大）维护了一个4位的保护关键字（由于内存MB量级，所有关键字并不会占据CPU内部过多空间），此外CPU中的</span><strong><span>PSW（program status word，程序状态字）</span></strong><span>中也维护了一个4位的关键字。于是每次进程尝试访问保护关键字不同于PSW中的内存块时，就会陷入内核。也就是说，进程只能访问和PSW中关键字一致的内存块，而PSW的关键字只能由操作系统修改。这样实现了多个程序在内存共存的一种保护机制。</span></p><p><span>然而，不能简单的将程序拷贝到内存某个位置。对于程序中跳转到绝对地址的指令，IBM 360采用了</span><strong><span>静态重定向（static relocation）</span></strong><span>——在加载到内存时，把那些需要重定向的地址/加上/代码程序被加载到的地址。但是这样会降低加载速度，也需要额外的信息去判断指令是否包含需重定向的地址。</span></p><p><span>即便没有内存抽象很古董，但是现在仍在嵌入式系统和智能卡系统中广泛应用，毕竟也没有用户能在吐司机上运行程序吧。</span></p><h3 id='32-地址空间'><span>3.2 地址空间</span></h3><h4 id='321-地址空间概念'><span>3.2.1 地址空间概念</span></h4><p><span>想让多个程序同时在内存中存在，需要保护和重定向两个要求。为此，人们提出了</span><strong><span>地址空间（address space）</span></strong><span>这一内存抽象。地址空间是一组进程可以用来访问内存的地址。每个进程有它自己独立的地址空间，当然也存在一些特殊情况需要进程共享部分地址空间。譬如进程A的地址28就和进程B的地址28是不同的物理地址。下面给出一个一度常见但是不再使用的方法：</span><strong><span>base and limit registers</span></strong><span>，其中base寄存器记录程序在内存中开始的地址，limit寄存器记录程序的长度。</span></p><p><span>首先采用了</span><strong><span>动态重定向（dynamic relocation）</span></strong><span>——在执行时完成重定向，而不是加载时。每当进程访问内存时（譬如取指令、读写内存），CPU硬件会自动把基地址加到进程生成的地址上去，然后再传到内存总线。其次用limit寄存器检查这个地址是否超过程序可以访问的范围了。</span></p><p><span>8088和8086采用了类似的技术，但是它只有base寄存器，没有limit寄存器。</span></p><p><span>这种动态重定向的方法需要一次加法和一次比较才能生成地址，仍然具有效率问题。</span></p><h4 id='322-交换技术'><span>3.2.2 交换技术</span></h4><p><span>当所有程序需要的内存大小超过了实际的物理内存大小（把20G的游戏全部加载到内存？肯定不行啊），有</span><strong><span>交换（swapping）</span></strong><span>和</span><strong><span>虚拟内存（virtual memory）</span></strong><span>两种解决手段。交换把整个程序全部仍到磁盘中，给内存留出空间；虚拟内存则允许程序部分在内存中就可以运行了。这里讨论交换技术。</span></p><p><img src="./img/mos3.2.2.jpg" style="zoom:15%;" /></p><p><span>上图展示了一系列swap过程，挺直观的，不多解释了。</span></p><p><span>交换过程中可能会在内存中产生一些hole，可以做</span><strong><span>内存压缩（memory compaction）</span></strong><span>让几个hole合并起来。但是这并不常见，因为这耗时巨大。</span></p><p><span>另一个需要解决的问题是为每个进程分配多大的内存呢？如果进程大小不变，那么分配刚刚好的内存是一个很好的选择。可是大部分进程大小是动态改变的，比如进程的栈和堆都会改变大小。那就多分配一些内存吧，当然在交换回磁盘时，这些多分配的没有使用的内存就不用交换回去了。如果进程把多分配的内存也用完了，可以将进程移动到一个更大的hole去、交换回磁盘、或者杀死算了。</span></p><h4 id='323-空闲内存管理'><span>3.2.3 空闲内存管理</span></h4><p><span>如何知道内存是否空闲呢，可以使用</span><strong><span>位图（bitmap）</span></strong><span>或者</span><strong><span>空闲列表（free list）</span></strong><span>来记录。下面依次介绍。</span></p><p><strong><span>Memory Management with Bitmaps</span></strong></p><p><span>如下图(a)(b)所示。将内存划分成多个allocation unit，每个allocation unit对应位图中的一位。allocation unit太小，就会占据过多内存存储位图；过大则会因进程大小不能很好贴合allocation unit的倍数而浪费内存。此外，遍历整个位图寻找连续k个空闲allocation unit耗时长。</span></p><p><img src="./img/mos3.2.3.jpg" style="zoom:15%;" /></p><p><strong><span>Memory Management with Linked Lists</span></strong></p><p><span>如上图(a)(c)所示。可以看到这个例子中链表是由地址排序的，这使得更新链表容易：当一个进程结束后，只需看看前面和后面是不是hole，是的话就合并起来（需要双向链表）。关于分配内存有不同的策略：</span></p><ul><li><strong><span>first fit</span></strong><span>：从头遍历链表，找到第一个足够大的hole就返回。快</span></li><li><strong><span>next fit</span></strong><span>：从上次返回的地址开始遍历链表，找到第一个足够大的hole就返回。研究表明性能略差于first fit。</span></li><li><strong><span>best fit</span></strong><span>：遍历整个链表，返回最小且足够大的hole。慢，性能甚至没有提高，因为倾向于让内存充满小而无用的hole。</span></li><li><strong><span>worst fit</span></strong><span>：遍历整个链表，返回最大的hole。也不是个好主意。</span></li></ul><p><span>可以通过对进程和hole维护不同的链表来加速上述四个策略，这样就可以花更多时间在查找hole上，而不是进程。然而这也造成一定实现难度：在收回内存时，如何将空闲段从进程链表移动到hole链表。我们还可以对hole链表根据大小排列，这样best fit策略就等同于first fit了，但是hole按照大小排列就失去了左右邻居的信息，使合并造成困难。还可以做一个优化：将信息存在hole之中，每个hole的最前面是hole大小，紧接着是指向下一个hole的指针，这样就不用显式的链表了。</span></p><ul><li><strong><span>quick fit</span></strong><span>：用一个多个条目的表格，每个条目指向一个固定范围大小的hole链表。这使得查找目标大小的hole很快，但是也使判断相邻位置是否是hole变得困难。</span></li></ul><p><span>这部分内容在csapp的第九章第九节有更详细的说明，且配套有malloc lab。</span></p><h3 id='33-虚拟内存'><span>3.3 虚拟内存</span></h3><p><span>尽管base and limit registers提供了地址空间的抽象，但是它们没法解决程序所需内存超过实际物理内存的问题。3.2.2我们讨论了交换技术解决该问题，但是反复从磁盘和内存之间交换数据，将耗时巨大。1960年代有方案将程序分成多个</span><strong><span>overlay</span></strong><span>，执行时就把overlay逐一加载到内存中，也就是说overlay是交换的最小单位，而不再是一整个程序。然而将程序分成overlay的操作是人工完成的，并不是一件容易的事情。而虚拟内存将解决这个难题。</span></p><p><strong><span>虚拟内存（virtual memory）</span></strong><span>的基本思想是：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一</span><strong><span>页（page，页面）</span></strong><span>。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，将触发</span><strong><span>缺页故障（page fault）</span></strong><span>，CPU将陷入操作系统，并由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</span></p><h4 id='331-分页和页表'><span>3.3.1 分页和页表</span></h4><p><span>由程序产生的这些地址称为</span><strong><span>虚拟地址（virtual address，VA）</span></strong><span>，它们构成了一个</span><strong><span>虚拟地址空间（virtual address space）</span></strong><span>。虚拟地址不是被直接送到内存总线上，而是被送到CPU内部的</span><strong><span>内存管理单元（Memory Management Unit，MMU）</span></strong><span>，MMU通过</span><strong><span>页表（page table）</span></strong><span>把虚拟地址映射为</span><strong><span>物理地址（physical address，PA）</span></strong><span>。在物理内存中页对应的单元称为</span><strong><span>页框/页帧 （page frame）</span></strong><span>，大小通常和页一样。x86-64支持4KB、2MB和1GB大小的页，通常用户程序使用4KB大小的页，而内核程序可以使用更大的页</span></p><p><span>这里给出一个MMU工作原理的例子：</span></p><p><img src="./img/mos3.3.1.jpg" style="zoom:15%;" /></p><p><span>可以看到，虚拟地址被分成</span><strong><span>虚拟页号（virtual page number，VPN）</span></strong><span>和</span><strong><span>偏移（offset）</span></strong><span>两部分，通过虚拟页号找到页表中的相关条目，用其中的</span><strong><span>页帧号/物理页号（page frame number/physical page number PPN）</span></strong><span>替换虚拟地址中的虚拟页号部分，从而生成了物理地址。这个例子中页大小为4KB，虚拟地址范围64KB，物理地址范围32KB。</span></p><p><span>让我们进一步看看页表中的条目（</span><strong><span>page table entry，PTE</span></strong><span>）。一个典型的页表条目包含：</span></p><ul><li><strong><span>page frame number</span></strong><span>：最重要部分，用来替换虚拟地址除offset的其余部分</span></li><li><strong><span>present/absent bit</span></strong><span>：用来判断条目是否有效，如果访问无效的页将会引发缺页故障</span></li><li><strong><span>protection bits</span></strong><span>：可以包含三位，依次表明是否可以读、写和执行</span></li><li><strong><span>modified bit</span></strong><span>：又称为</span><strong><span>脏位（dirty bit）</span></strong><span>。来表明该页有没有被修改，如果修改了，在操作系统收回对应页帧时，需要将其写回磁盘；如果没有修改，直接丢弃就好了</span></li><li><strong><span>referenced bit</span></strong><span>：表明该页最近被读写过了，在之后讨论的页面置换算法有用处。</span></li><li><strong><span>caching disabled bit</span></strong><span>：对于内存映射IO的机器，通过设置该位使得每次访问该页将读取IO设备的内容，而不是之前缓存在内存中的内容。</span></li></ul><h4 id='332-加速分页'><span>3.3.2 加速分页</span></h4><p><span>之前讨论的方案将整个页表放在内存中，并使用一个特殊的CPU寄存器</span><strong><span>页表基址寄存器（Page Table Base Register）</span></strong><span>来存放页表的起始地址，每次访问内存先要访问内存中的页表，这会使得每次访问内存实际上访问了两次，如下面左图2、4所示：（右图产生缺页故障，左图没有）</span></p><p><img src="./img/2022-04-20 14-02-06 的屏幕截图.png" referrerpolicy="no-referrer"></p><p><span>为了加速访问内存，我们可以CPU内部加入一点硬件存放一些PTE，这个硬件便是</span><strong><span>TLB（Translation Lookaside Buffer，翻译后备缓冲器）</span></strong><span>。TLB中存放的PTE个数不大，通常不超过256个。（严格来说不能说TLB存放PTE，应该说存放物理页号、有效位、修改位等等）</span></p><p><span>下图左是TLB命中，下图右是TLB未命中。当虚拟地址传到MMU后，MMU先通过虚拟页号在TLB中快速寻找对应的PTE，再利用PTE生成物理地址。如果没有找到对应PTE，MMU将会在内存中的页表做常规的查找，并将替换TLB中的一个条目。注意到整个过程由硬件实现。</span></p><p><img src="./img/2022-04-20 14-15-23 的屏幕截图.png" style="zoom:67%;" /></p><p><strong><span>软件管理TLB</span></strong></p><p><span>在之前的设计中，TLB的管理和如何处理TLB miss都是完全由MMU硬件处理的，只有缺页故障才会陷入内核，交给操作系统处理。当下一些RISC机器把TLB管理交给软件实现。也就是操作系统负责找对应PTE，替换TLB的条目等。虽然会更多陷入内核，但是由于更简单的MMU硬件、CPU也有更多空间提升其他特征，所以效果还不错。软件实现管理也更灵活，我们可以猜测需要加载进TLB的PTE项，来避免之后的TLB未命中。</span></p><p><strong><span>上下文切换时TLB怎么办</span></strong></p><p><span>上下文切换时，对于页表只需改变页表基址寄存器的值就好了，那么TLB怎么办呢？一个简单的方法是把TLB中的所有有效位置为0，相当于清空了TLB，虽然可行，但在切换后会产生大量TLB miss。为了避免这种开销，我们可以在TLB中增加一个</span><strong><span>地址空间标识符（address space identifier，ASID）</span></strong><span>，类似于进程标识符PID，进程在访问TLB时就知道这个TLB项是不是自己的，从而实现了TLB共享。</span></p><h4 id='333-针对太大的页表'><span>3.3.3 针对太大的页表</span></h4><p><span>在一个32位地址空间中，每个页面大小为4KB，则一共需要 </span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="19.431ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 8588.4 1083.9" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-24-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-24-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path id="MJX-24-TEX-N-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path><path id="MJX-24-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-24-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-24-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-24-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-24-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="33" xlink:href="#MJX-24-TEX-N-33"></use><use data-c="32" xlink:href="#MJX-24-TEX-N-32" transform="translate(500,0)"></use></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1290.1,0)"><g data-mml-node="mo"><use data-c="2F" xlink:href="#MJX-24-TEX-N-2F"></use></g></g><g data-mml-node="msup" transform="translate(1790.1,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-24-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="31" xlink:href="#MJX-24-TEX-N-31"></use><use data-c="32" xlink:href="#MJX-24-TEX-N-32" transform="translate(500,0)"></use></g></g></g><g data-mml-node="mo" transform="translate(3358,0)"><use data-c="3D" xlink:href="#MJX-24-TEX-N-3D"></use></g><g data-mml-node="msup" transform="translate(4413.8,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-24-TEX-N-32"></use></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-24-TEX-N-32"></use><use data-c="30" xlink:href="#MJX-24-TEX-N-30" transform="translate(500,0)"></use></g></g></g><g data-mml-node="mo" transform="translate(5981.7,0)"><use data-c="3D" xlink:href="#MJX-24-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(7037.4,0)"><use data-c="31" xlink:href="#MJX-24-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(7537.4,0)"><use data-c="1D440" xlink:href="#MJX-24-TEX-I-1D440"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow data-mjx-texclass="ORD"><mn>32</mn></mrow></msup><mrow data-mjx-texclass="ORD"><mo>/</mo></mrow><msup><mn>2</mn><mrow data-mjx-texclass="ORD"><mn>12</mn></mrow></msup><mo>=</mo><msup><mn>2</mn><mrow data-mjx-texclass="ORD"><mn>20</mn></mrow></msup><mo>=</mo><mn>1</mn><mi>M</mi></math></mjx-assistive-mml></mjx-container><script type="math/tex">2^{32}/2^{12}=2^{20}=1M</script><span> 个页面，假设每个PTE大小为4字节，则页表总共为4MB。我们又知道每个进程有自己的页表，倘若100个进程，那么内存中页表就占400MB了。这显然是不可接受的。下面讨论两种解决方法。</span></p><p><strong><span>多级页表</span></strong></p><p><span>下面是一个两级页表的例子。通过32位地址的前十位PT1用来检索第一级页表，中间十位PT2用来检索第二级页表，在二级页表中找到对应的物理页号替换虚拟地址的PT1和PT2部分，从而生成了最终的物理地址。32位的虚拟地址对应着4GB的虚拟地址空间，在这个设计中如果物理页号是20位的，那么最后生成的物理地址也是32位的，对应了4GB的物理地址空间。此外如果PTE的大小是32位，那么一个有1024个PTE的页表的大小是4KB，也正好是一个页的大小。所有这些页表组成了</span><strong><span>页目录（page directory）</span></strong><span>。</span></p><p><span>之所以可以节约空间，是由于我们不需要将所有的页表都存在内存中，譬如该例子只用了四个页表。此外内存中只需保存一级页表和较常使用的二级页表，进一步减小了内存的压力。</span></p><p><img src="./img/mos3.3.4.jpg" style="zoom:18%;" /></p><p><span>在英特尔64位处理器的实现中，虚拟地址其实只有48位，采用了4级页表，最后生成的物理地址有52位。也就是说虚拟地址空间是2</span><sup><span>48</span></sup><span>B，物理地址空间是2</span><sup><span>52</span></sup><span>B=256TB。细节如下图所示，具体缓存设计并不是操作系统课程关心的，需移步计算机组成。</span></p><p><img src="https://iewug.github.io/pic/csapp/i7_virtual memory.jpg" alt="img" style="zoom:67%;" /></p><p><strong><span>反向页表（inverted page table）</span></strong></p><p><span>曾经在PowerPC等处理器上采用过。不再是每个页一个条目，而是每个页帧一个条目。譬如在64位的机器上，一个4GB的RAM，采用4KB大的页，那么反向页表需要2</span><sup><span>20</span></sup><span>个条目。而如果采用36位VPN的话，普通的一级页表要2</span><sup><span>36</span></sup><span>个条目。虽然反向页表能节省空间，但是导致了虚拟地址到物理地址不易转换。可以用哈希表来解决这个问题，这里不再过多展开。</span></p><h3 id='34-页面置换算法'><span>3.4 页面置换算法</span></h3><p><span>当发生缺页故障时，操作系统需要从内存中移除一个页，并把目标页从磁盘拷贝进来。移除哪个页就是页面置换算法所关心的。</span></p><h4 id='341-最优页面置换算法'><span>3.4.1 最优页面置换算法</span></h4><p><strong><span>最优页面置换算法（the optimal page replacement algorithm）</span></strong><span>就是移除未来最晚会使用的页。虽然不具备可行性，但是可以用来评估其他算法在具体依次运行的表现。</span></p><h4 id='342-最近未使用页面置换算法'><span>3.4.2 最近未使用页面置换算法</span></h4><p><strong><span>NRU（not recently used）</span></strong><span>算法利用PTE中的R（referenced bit）和M（modified bit）位将页面分成四类：</span></p><ol start='0' ><li><span>not referenced, not modified</span></li><li><span>not referenced, modified</span></li><li><span>referenced, not modified</span></li><li><span>referenced, modified</span></li></ol><p><span>最先移除第0类中的页面，最后移除第3类的。R位在页面被读写的时候设置为1，周期性（譬如在每个时钟中断时）所有页面的R位被清除置为0.</span></p><h4 id='343-先进先出页面置换算法'><span>3.4.3 先进先出页面置换算法</span></h4><p><strong><span>FIFO</span></strong><span>算法可以通过维护一个队列实现，缺页故障时移除队首页面，在队尾加入新的页面。存在大问题：最老的页面仍然可能是有用的。</span></p><h4 id='344-第二次机会页面置换算法'><span>3.4.4 第二次机会页面置换算法</span></h4><p><strong><span>second chance</span></strong><span>算法是对FIFO的一个改进。同样是维护一个队列，但在移除队首页面时，如果其R位为1，则将其放回队尾且将R位设置为0，检查后一个页面；如果R位为0，那么就移除。如果所有页面的R位都是1，那么second chance将等同于FIFO。此外，书上没有写明周期性清除所有R位，但是透露了这种意思。</span></p><h4 id='345-时钟页面置换算法'><span>3.4.5 时钟页面置换算法</span></h4><p><strong><span>clock</span></strong><span>算法是对second chance的一个改进，不再使用队列，而是使用一个类似循环链表的数据结构。这样就不用做队首删除队尾插入的操作了，直接在需要被移除页面的位置做替换就好了。具体细节如下图：</span></p><p><img src="./img/mos3.4.5.jpg" style="zoom:15%;" /></p><h4 id='346-最近最少使用页面置换算法'><span>3.4.6 最近最少使用页面置换算法</span></h4><p><strong><span>LRU（Least Recently Used）</span></strong><span>算法移除历史上最久没有使用的页面。但是并不容易实现，我们需要维护一个链表，最前面是最近使用过的页面。注意到不同于FIFO只需要在缺页故障时更新队列，LRU要求每次页面访问都要更新链表。从链表中找到这个页面，再将其从链表某个位置删除后放到链表最前面，会耗时巨大。</span></p><p><span>或者我们维护一个时间戳，每次内存访问，就给对应的PTE更新时间戳。到时候移除最古老的时间戳就行了。</span></p><h4 id='347-用软件模拟lru'><span>3.4.7 用软件模拟LRU</span></h4><p><span>书上意思3.4.6节的实现是通过硬件的，下面这个</span><strong><span>aging</span></strong><span>算法是通过软件实现LRU的。每个页面维护一个8位的二进制数。在每个时钟中断时，将八位二进制数右移一位，将R位放到最高位；然后将所有R位清零，开始下一个周期。如果在（e）时缺页故障发生，由于page3的数字最小，所以page3将被替换。（其实aging前还提及了</span><strong><span>NFU，not frequently used</span></strong><span>算法，就是在时钟中断时每个页面加上自己的R位，然后清零R位）</span></p><p><img src="./img/mos3.4.7.jpg" style="zoom:18%;" /></p><h4 id='348-工作集页面置换算法'><span>3.4.8 工作集页面置换算法</span></h4><p><span>进程的</span><strong><span>工作集（working set）</span></strong><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="6.382ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2820.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-25-TEX-I-1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"></path><path id="MJX-25-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-25-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-25-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path><path id="MJX-25-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-25-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D464" xlink:href="#MJX-25-TEX-I-1D464"></use></g><g data-mml-node="mo" transform="translate(716,0)"><use data-c="28" xlink:href="#MJX-25-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1105,0)"><use data-c="1D458" xlink:href="#MJX-25-TEX-I-1D458"></use></g><g data-mml-node="mo" transform="translate(1626,0)"><use data-c="2C" xlink:href="#MJX-25-TEX-N-2C"></use></g><g data-mml-node="mi" transform="translate(2070.7,0)"><use data-c="1D461" xlink:href="#MJX-25-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(2431.7,0)"><use data-c="29" xlink:href="#MJX-25-TEX-N-29"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>w</mi><mo stretchy="false">(</mo><mi>k</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container><script type="math/tex">w(k,t)</script><span>定义为：在时刻t下，该进程最近k次内存访问所访问过的页面的集合。于是工作集页面置换算法就是移除不在该进程工作集中的页面。然而这并不容易实现，可以将定义修改为最近k时间内访问过的页面集合，下面给出这种定义下的实现：</span></p><p><span>每个进程用的CPU时间称为</span><strong><span>current virtual time</span></strong><span>，在页表里记录上次被访问的时间，每个时钟中断清除所有的R位。当缺页故障发生后，扫描整个页表直到发现可以移除的PTE，按照图中所示做相关操作。图中age=current virtual time - time of last use，</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="1.17ex" height="1.005ex" role="img" focusable="false" viewBox="0 -431 517 444" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.029ex;"><defs><path id="MJX-29-TEX-I-1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D70F" xlink:href="#MJX-29-TEX-I-1D70F"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>τ</mi></math></mjx-assistive-mml></mjx-container><script type="math/tex">\tau</script><span>是一个大于一个时钟周期，预设好的值。若遍历完整个页表也没有找到可以移除的PTE，若存在R=0的PTE，那就移除其中最老的那个（即便没有超过</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="1.17ex" height="1.005ex" role="img" focusable="false" viewBox="0 -431 517 444" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.029ex;"><defs><path id="MJX-29-TEX-I-1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D70F" xlink:href="#MJX-29-TEX-I-1D70F"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>τ</mi></math></mjx-assistive-mml></mjx-container><script type="math/tex">\tau</script><span>），若不存在R=0的PTE，那就随机移除一个，最好是一个M位=0的（这样不用更新磁盘）。</span></p><p><img src="./img/mos3.4.8.jpg" style="zoom:18%;" /></p><h4 id='349-工作集时钟页面置换算法'><span>3.4.9 工作集时钟页面置换算法</span></h4><p><span>3.4.8的算法太笨重了，</span><strong><span>WSClock</span></strong><span>更加简单且表现不俗。PTE组成一个循环链表。若指针指向的PTE的R位为1，则更新为0，指针前移，继续；若指向的R位为0，M位为0，且年龄超过了预设的</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="1.17ex" height="1.005ex" role="img" focusable="false" viewBox="0 -431 517 444" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.029ex;"><defs><path id="MJX-29-TEX-I-1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D70F" xlink:href="#MJX-29-TEX-I-1D70F"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>τ</mi></math></mjx-assistive-mml></mjx-container><script type="math/tex">\tau</script><span>，就移除该PTE，结束；若R=0，M=1，且年龄超过了预设的</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="1.17ex" height="1.005ex" role="img" focusable="false" viewBox="0 -431 517 444" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.029ex;"><defs><path id="MJX-29-TEX-I-1D70F" d="M39 284Q18 284 18 294Q18 301 45 338T99 398Q134 425 164 429Q170 431 332 431Q492 431 497 429Q517 424 517 402Q517 388 508 376T485 360Q479 358 389 358T299 356Q298 355 283 274T251 109T233 20Q228 5 215 -4T186 -13Q153 -13 153 20V30L203 192Q214 228 227 272T248 336L254 357Q254 358 208 358Q206 358 197 358T183 359Q105 359 61 295Q56 287 53 286T39 284Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D70F" xlink:href="#MJX-29-TEX-I-1D70F"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>τ</mi></math></mjx-assistive-mml></mjx-container><script type="math/tex">\tau</script><span>，将该页写回磁盘放入调度，指针前移，继续；若跑了一圈没有合适的PTE，若之前有写回磁盘的调度，那么就移除第一个遇到的干净页面，若之前没有磁盘调度，找一个干净的页移除，全不干净就移除当前页。</span></p><p><span>（所以这个算法并不是在移除的时候写回磁盘欸）</span></p><p><img src="./img/mos3.4.9.jpg" style="zoom:18%;" /></p><h4 id='3410-小结'><span>3.4.10 小结</span></h4><p><span>几个算法总结如下：</span></p><figure><table><thead><tr><th><span>Algorithm</span></th><th><span>Comment</span></th></tr></thead><tbody><tr><td><span>optimal</span></td><td><span>not implementable, but useful as a benchmark</span></td></tr><tr><td><span>NRU</span></td><td><span>very crude approximation of LRU</span></td></tr><tr><td><span>FIFO</span></td><td><span>might throw out important pages</span></td></tr><tr><td><span>second chance</span></td><td><span>big improvement over FIFO</span></td></tr><tr><td><span>clock</span></td><td><span>realistic</span></td></tr><tr><td><span>LRU</span></td><td><span>excellent, but difficult to implement exactly</span></td></tr><tr><td><span>NFU</span></td><td><span>fairly crude approximation to LRU</span></td></tr><tr><td><span>aging</span></td><td><span>efficient algorithm that approximates LRU well</span></td></tr><tr><td><span>working set</span></td><td><span>somewhat expensive to implement</span></td></tr><tr><td><span>WSClock</span></td><td><span>good efficient algorithm</span></td></tr></tbody></table></figure><p><span>建议：使用aging或者WSClock</span></p><h3 id='35-分页系统中的设计问题'><span>3.5 分页系统中的设计问题</span></h3><h4 id='351-页面分配策略'><span>3.5.1 页面分配策略</span></h4><p><strong><span>驻留集（resident set）</span></strong><span>是指操作系统给某进程分配的页面的集合。</span></p><p><strong><span>工作集（working set）</span></strong><span>是指一段时间内，进程实际访问的页面集合。</span></p><p><strong><span>页面分配、置换策略</span></strong></p><ul><li><strong><span>固定分配VS可变分配</span></strong><span>：区别在与进程运行期间驻留集大小是否可变</span></li><li><strong><span>局部置换VS全局置换</span></strong><span>：区别在与发生缺页故障时是否只能从进程自己的页面中选一个换出</span></li><li><strong><span>固定分配局部替换</span></strong><span>：进程运行前就分配一定数量的物理块，缺页时只能换出自己的某一页。当进程大小改变时，会造成浪费和抖动。</span></li><li><strong><span>可变分配全局替换</span></strong><span>：只要某进程发生缺页，都将获得新的物理块。如果没有空闲物理块，就从所有进程的页面中进行页面置换算法。</span></li><li><strong><span>可变分配局部替换</span></strong><span>：每个进程计算</span><strong><span>PFF（page fault frequency）</span></strong><span>，即单位时间缺页数。当PFF大于阈值，多分配一点物理块；当PFF小于阈值，回收一点物理块。</span></li></ul><p><strong><span>何时调入页面</span></strong></p><ul><li><strong><span>预调页策略（prepaging）</span></strong><span>：进程运行前</span></li><li><strong><span>请求调页策略（demand paging）</span></strong><span>：进程运行时，发现缺页再调页</span></li></ul><p><strong><span>抖动（thrashing）</span></strong><span>是指页面频繁换入换出的现象。</span></p><h4 id='352-负载控制'><span>3.5.2 负载控制</span></h4><p><span>当抖动难以避免（譬如所有进程的PFF都大于阈值了），解决方法只有将部分进程交换进磁盘了。可见分页下依旧需要交换机制。</span></p><h4 id='353-页面大小'><span>3.5.3 页面大小</span></h4><p><span>小页面</span><strong><span>优势</span></strong><span>：避免</span><strong><span>内部碎片（internal fragmentation）</span></strong><span>，节约内存。</span></p><p><span>小页面</span><strong><span>劣势</span></strong><span>：过大的页表，TLB不够用，更多缺页故障</span></p><p><span>通常用户程序使用4KB大小的页，内核程序可能使用更大的页。</span></p><h4 id='354-分离的指令空间和数据空间'><span>3.5.4 分离的指令空间和数据空间</span></h4><p><span>可以将指令空间和数据空间分开，它们有独立的页表。好处在于，在翻倍地址空间的同时，并没有给操作系统引入更多的复杂性。事实上，现在的L1缓存就是把指令和数据分离的。</span></p><h4 id='355-共享页面'><span>3.5.5 共享页面</span></h4><p><span>共享页面就是让两个进程的页表指向同一个页帧，显然这可以节约内存。一般来说，那些只读的页面（譬如程序文本）可以共享，但是数据页面难以共享。当进程A和进程B共享一个页面时，进程A结束时，操作系统知道进程B还在使用这些页面是有必要的，这样这些页面才不会被随意移除。</span></p><p><span>共享数据很典型的就是</span><code>fork</code><span>指令。采用</span><strong><span>写时复制（copy-on-write）</span></strong><span>技术。很多时候fork完就直接execve了，完全没有必要在fork时就把内存空间复制到另一块去。fork后，父子进程分别拥有它们自己的页表，但都指向同一个页面集合，这些页面标记为只读。只有虚拟地址被写入时，物理地址上的数据才被复制。</span></p><h4 id='356-共享库'><span>3.5.6 共享库</span></h4><p><strong><span>共享库（shared library）</span></strong><span>也称为</span><strong><span>动态链接库（dynamic link library，DLL）</span></strong><span>，也就是在加载或者执行的时候才进行链接，而不是编译的时候。CSAPP的第七章有相当详细的讨论（不过很难读）。这里强调一点，无论是静态链接还是动态链接，都只把程序用到的库函数链接进去，并不是整个库都链接进去。</span></p><h4 id='357-内存映射文件'><span>3.5.7 内存映射文件</span></h4><p><strong><span>内存映射文件（memory-mapped file）</span></strong><span>的思想是：进程可以通过发起一个系统调用，将一个文件映射到其虚拟地址空间的一部分。如果两个或两个以上的进程同时映射了同一个文件，它们就可以通过共享内存来通信。很显然，如果内存映射文件可用，共享库就可以使用这个机制。</span></p><h4 id='358-清除策略'><span>3.5.8 清除策略</span></h4><p><span>为保证有足够的空闲页框，很多分页系统有一个称为</span><strong><span>分页守护进程（paging  daemon）</span></strong><span>的后台进程，它在大多数时候睡眠，但定期被唤醒以检查内存的状态。如果空闲页框过少，分页守护进程通过预定的页面置换算法选择页面换出内存。如果这些页面装入内存后被修改过，则将它们写回磁盘。</span></p><h4 id='359-虚拟内存接口'><span>3.5.9 虚拟内存接口</span></h4><p><span>提供虚拟内存接口，给程序员做内存映射的权利，从而加强程序的行为。这里不多展开。</span></p><h3 id='36-有关实现的问题'><span>3.6 有关实现的问题</span></h3><p><em><span>我只选了其中三个看得懂的整理</span></em></p><h4 id='361-何时做分页工作'><span>3.6.1 何时做分页工作</span></h4><p><span>操作系统在进程创建、进程执行、缺页故障和进程结束四种情况将做分页相关的工作。</span></p><ul><li><span>进程创建：需要决定给程序分配多少页面，并创建页表。有些系统磁盘的交换分区需要留出一些地方初始化为程序的文本和数据，有些系统直接可以从磁盘上的可执行文件page the program text，就不需要交换分区的初始化了。最后，页表和交换分区的信息要存入进程表。</span></li><li><span>进程执行：MMU需重置，TLB需清空，页表基址寄存器需指向页表，可能还会加载一些或者全部的页面到内存里</span></li><li><span>缺页故障：从寄存器得到造成缺页故障的虚拟地址，计算所需的页面并在磁盘上找到它。找一个合适的页帧放置它。重新执行这条指令。</span></li><li><span>进程结束：回收页表、页面、页面占据的磁盘空间。</span></li></ul><h4 id='362-缺页故障处理'><span>3.6.2 缺页故障处理</span></h4><ol start='' ><li><span>硬件陷入内核，保存PC于栈。一些当前指令的状态信息保存在特殊的CPU寄存器</span></li><li><span>汇编程序保存通用寄存器和其同易失信息，然后调用操作系统</span></li><li><span>操作系统发现缺页故障，寻找所需的页面的虚拟地址。通常相关信息存在一个硬件寄存器中。</span></li><li><span>操作系统检查地址有效位和保护位，出现问题就给进程发送信号或者直接杀死。找页帧来存放这个页面</span></li><li><span>如果页帧是脏的，需要写回磁盘，写回过程中故障进程被挂起</span></li><li><span>当页帧干净后，从磁盘中寻找并将所需页写入内存。此时故障进程被挂起。</span></li><li><span>写完后，硬件中断发过来，页表更新</span></li><li><span>把PC等设置为引发缺页故障的指令</span></li><li><span>故障进程被调度，操作系统交还给汇编程序</span></li><li><span>汇编程序恢复之前保存的寄存器和其他信息，回到用户空间，继续那条引发缺页故障的指令。好似什么也没有发生过。</span></li></ol><h4 id='363-交换分区'><span>3.6.3 交换分区</span></h4><p><span>交换出去的页面放在磁盘的交换分区，没有正常的文件系统。当进程创建时，一个简单的做法是在交换分区划出和进程一样大的区域并初始化为进程的内容，进程表记录该交换分区的起始位置（下图左）。另一个极端做法是进程创建时不预先分配交换分区，只有当页面交换出去了再分配，节约磁盘的同时也要求使用一个额外的表格记录映射（下图右）。</span></p><p><img src="./img/mos3.6.5.jpg" style="zoom:18%;" /></p><p><span>事实上，个人电脑不用交换空间都行，因为内存已经足够大了。用</span><code>free</code><span>指令可以查看交换空间信息，我此时的输出如下：（根本没有用交换空间）</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="bash"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">❯ free</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  总计 &nbsp; &nbsp; &nbsp; &nbsp; 已用 &nbsp; &nbsp; &nbsp;  空闲 &nbsp; &nbsp;  共享 &nbsp;  缓冲/缓存 &nbsp;  可用</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">内存： &nbsp; &nbsp;<span class="cm-number">16310992</span> &nbsp; &nbsp; <span class="cm-number">2305868</span> &nbsp; &nbsp; <span class="cm-number">9573440</span> &nbsp; &nbsp; &nbsp;<span class="cm-number">551416</span> &nbsp; &nbsp; <span class="cm-number">4431684</span> &nbsp; &nbsp;<span class="cm-number">13119056</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">交换： &nbsp; &nbsp; <span class="cm-number">2097148</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="cm-number">0</span> &nbsp; &nbsp; <span class="cm-number">2097148</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 91px;"></div><div class="CodeMirror-gutters" style="display: none; height: 91px;"></div></div></div></pre><h3 id='37-分段'><span>3.7 分段</span></h3><p><em><span>就随便谈谈自己的理解了</span></em></p><p><span>之前我们讨论程序的地址空间都只有一段，所有的内容（数据、文本、符号表等等）都是在同一个地址空间下的。那如果地址空间不够大，就可能发生向下生长的栈和向上生长的堆撞在一起（当然不大可能，我乱举的例子）。</span><strong><span>分段（segmentation）</span></strong><span>就是将这些数据段、代码段等等分开来，每个段有独立的地址空间，可以独立伸缩也不影响别人。3.2.1节提及的limit and base register其实就是分段了。每个段有自己的一组寄存器就可以了。分段还有其他好处，譬如简化链接、保护、共享等等。单纯的分段会在物理内存中产生</span><strong><span>外部碎片（external fragmentation）</span></strong><span>，即段与段之间的物理内存由于放不进其他段而需要被浪费。为此可以采用分页和分段相结合的手段，书上给出了MULTICS和x86的两种实现。</span></p><p><span>但事实上分段已经在被淘汰了，即便是一个优秀的想法。当下无论是UNIX还是Windows操作系统其实都是把base设置为0，limit设置为最大，在支持分段的CPU上使用一个段。Intel的x86-64处理器也不再支持分段了。主要原因是操作系统的设计者们不愿意改变自己的内存模型，提出一个x86 specific的系统。</span></p><hr /><div style="page-break-after: always;"></div> <h2 id='四文件系统'><span>四、文件系统</span></h2><p><strong><span>文件（file）</span></strong><span>是一种抽象，提供了在磁盘上存储和访问信息的方法。通过文件，用户不用知道信息是怎么存储在磁盘上，也不用知道磁盘怎么工作。操作系统中管理文件的部分称为</span><strong><span>文件系统（file system）</span></strong><span>，它负责管理文件的结构、命名、访问、使用、实现、保护等等。在讨论文件系统时，可以简单地将磁盘认为由连续的一个一个</span><strong><span>块（block）</span></strong><span>组成，并允许操作系统读写某个块。</span></p><p><span>本章先从用户视角出发，然后逐步深入到内部实现，最后讨论几种文件系统的例子。</span></p><h3 id='41-文件'><span>4.1 文件</span></h3><p><span>4.1节讨论用户视角对文件的理解。</span></p><h4 id='411-文件命名'><span>4.1.1 文件命名</span></h4><ul><li><span>是否区分大小写：UNIX区分，MS-DOS不区分</span></li><li><strong><span>文件扩展名（file extension）</span></strong><span>：譬如</span><code>test.c</code><span>，</span><code>.c</code><span>就是文件扩展名。在UNIX系统下，文件扩展名只是个惯例，并不被操作系统要求。不过文件扩展名不仅可以提示用户文件类型，而且譬如c语言编译器要求文件以</span><code>.c</code><span>结尾，所以文件扩展名很有用。相反，Windows系统意识到这些文件扩展名，用户也可以register extensions with the operating system and specify for each one which program &quot;owns&quot; that extension. (e.g. Microsoft Word for </span><code>.docx</code><span>)</span></li></ul><h4 id='412-文件结构'><span>4.1.2 文件结构</span></h4><p><span>给出了三种普通文件（见4.1.3）的结构</span></p><ul><li><span>字节序列：把文件看作字节序列。灵活。UNIX和windows都采用了这种方式。</span></li><li><span>记录序列：把文件看作是定长的记录（record）序列。这种结构的核心是：读操作返回一个记录；写操作重写或追加一个记录。每个记录有其内部结构。古老的大型机采用的方式。</span></li><li><span>树：将记录组成树结构，每个记录长度不用相等。每个记录有键值，按键排序，对键查找，OS决定记录放在哪。B树。用于商业数据处理的大型机。</span></li></ul><p><img src="./img/20210602112433843.png" style="zoom:50%;" /></p><h4 id='413-文件类型'><span>4.1.3 文件类型</span></h4><ul><li><p><strong><span>普通文件（regular file）</span></strong><span>：包含用户信息</span></p><ul><li><span>ASCII文件：文本文件</span></li><li><span>二进制文件：可执行文件（文件头的</span><strong><span>魔数magic number</span></strong><span>用来表明文件是一个可执行文件）、存档文件（archive，编译但未链接的库过程模块组成）。具体见后图。</span></li></ul></li><li><p><strong><span>目录（directory）</span></strong><span>：用来维护文件系统结构的系统文件</span></p></li><li><p><strong><span>字符特殊文件（character special file）</span></strong><span>：I/O相关</span></p></li><li><p><strong><span>块特殊文件（block special file）</span></strong><span>：to model disks</span></p></li></ul><p><img src="./img/20210602112551673.png" style="zoom:50%;" /></p><h4 id='414-文件访问'><span>4.1.4 文件访问</span></h4><ul><li><p><strong><span>顺序访问（sequential access）</span></strong><span>：文件必须从头到尾按顺序访问全部内容，不可跳过。</span></p></li><li><p><strong><span>随机访问（random access）</span></strong><span>：被广泛使用。</span></p><p><span>指示从何处开始读文件：</span></p><ul><li><span>read操作给出位置。</span></li><li><span>利用seek操作设置当前位置。被UNIX和windows采用。</span></li></ul></li></ul><h4 id='415-文件属性'><span>4.1.5 文件属性</span></h4><p><span>除了文件名和数据外，创建时间、文件大小等其他信息称做文件</span><strong><span>属性（attribute）</span></strong><span>或者</span><strong><span>元数据（metadata）</span></strong><span>。下面是一些例子：</span></p><p><img src="./img/20210602112623120.png" style="zoom:50%;" /></p><h4 id='416-文件操作'><span>4.1.6 文件操作</span></h4><p><span>create, delete, open, close, read, write, append, seek, get attributes, set attributes, rename</span></p><p><span>无需更多解释。</span></p><h4 id='417-文件系统调用程序的例子'><span>4.1.7 文件系统调用程序的例子</span></h4><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">/**</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> <span class="cm-comment">* copyfile A B: copy the file A to B</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> <span class="cm-comment">*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#include &lt;sys/types.h&gt;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#include &lt;fcntl.h&gt;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#include &lt;stdlib.h&gt;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#include &lt;unistd.h&gt;</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define BUF_ SIZE 4096 </span><span class="cm-comment">/*使用一个4096字节大小的缓冲区*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">#define OUTPUT_ MODE 0700 </span><span class="cm-comment">/*输出文件的保护位*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">int</span> <span class="cm-def">main</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">argc</span>, <span class="cm-variable-3">char</span> <span class="cm-variable-3">*</span><span class="cm-variable">argv</span>[])</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable-3">int</span> <span class="cm-variable">in_fd</span>, <span class="cm-variable">out_fd</span>, <span class="cm-variable">rd_count</span>, <span class="cm-variable">wt_count</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable-3">char</span> <span class="cm-variable">buffer</span>[<span class="cm-variable">BUF_SIZE</span>];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">/*argv[0]="copyfile",argv[1]="A",argv[2]="B" */</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">argc</span> <span class="cm-operator">!=</span> <span class="cm-number">3</span>) <span class="cm-variable">exit</span>(<span class="cm-number">1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">/*打开输入文件并创建输出文件*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">in_fd</span> <span class="cm-operator">=</span> <span class="cm-variable">open</span>(<span class="cm-variable">argv</span>[<span class="cm-number">1</span>], <span class="cm-variable">O_</span> <span class="cm-variable">RDONLY</span>); <span class="cm-comment">/* 打开源文件*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">if</span>(<span class="cm-variable">in_fd</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>) <span class="cm-variable">exit</span>(<span class="cm-number">2</span>);<span class="cm-comment">/*如果该文件不能打开，退出*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">out_fd</span> <span class="cm-operator">=</span> <span class="cm-variable">creat</span>(<span class="cm-variable">argv</span>[<span class="cm-number">2</span>], <span class="cm-variable">OUTPUT_MODE</span>); <span class="cm-comment">/* 创建目标文件*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">out_fd</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>) <span class="cm-variable">exit</span>(<span class="cm-number">3</span>); <span class="cm-comment">/*如果该文件不能被创建，退出*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">/*copy loop*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span> (<span class="cm-variable">TRUE</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">rd</span> <span class="cm-variable">count</span><span class="cm-operator">=</span> <span class="cm-variable">read</span>(<span class="cm-variable">in_fd</span>, <span class="cm-variable">buffer</span>, <span class="cm-variable">BUF_SIZE</span>);<span class="cm-comment">/* 读一块数据*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">rd_count</span> <span class="cm-operator">&lt;=</span> <span class="cm-number">0</span>) <span class="cm-keyword">break</span>; <span class="cm-comment">/*如果文件结束或读时出错，退出循环*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">wt_count</span> <span class="cm-operator">=</span> <span class="cm-variable">write</span>(<span class="cm-variable">out_fd</span>, <span class="cm-variable">buffer</span>, <span class="cm-variable">rd_count</span>); <span class="cm-comment">/*写数据*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">wt_count</span> <span class="cm-operator">&lt;=</span> <span class="cm-number">0</span>) <span class="cm-variable">exit</span>(<span class="cm-number">4</span>); <span class="cm-comment">/*wt_count &lt;=0是一个错误*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-comment">/*关闭文件*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">close</span>(<span class="cm-variable">in_fd</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">close</span>(<span class="cm-variable">out_fd</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">if</span>(<span class="cm-variable">rd_count</span><span class="cm-operator">==</span><span class="cm-number">0</span>) <span class="cm-comment">/*没有读取错误*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  <span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">exit</span>(<span class="cm-number">0</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">else</span> <span class="cm-comment">/*有读取错误发生*/</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  <span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">exit</span>(<span class="cm-number">5</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 929px;"></div><div class="CodeMirror-gutters" style="display: none; height: 929px;"></div></div></div></pre><p><span>应该看得懂吧。注意到</span><code>in_fd</code><span>和</span><code>out_fd</code><span>称为</span><strong><span>文件描述符（file descriptor）</span></strong><span>。当文件成功打开时，系统给文件分配的一个整数，后续使用这个整数，程序知道是哪个文件。</span></p><h3 id='42-目录'><span>4.2 目录</span></h3><p><strong><span>目录（directory）</span></strong><span>又称</span><strong><span>文件夹（folder）</span></strong><span>，自身也是文件。4.2节讨论用户视角对目录的理解。</span></p><h4 id='421-一级目录系统'><span>4.2.1 一级目录系统</span></h4><p><strong><span>一级目录系统（single-level directory system）</span></strong><span>只有一个目录，其包含所有文件。这个目录有时称做</span><strong><span>根目录（root directory）</span></strong><span>，不过既然只有一个目录，它的名字并不那么重要了。应用于最早的计算机，以及当下一些嵌入式设备。</span></p><p><img src="./img/2022-04-29 18-15-21 的屏幕截图.png" style="zoom:67%;" /></p><h4 id='422-层次目录系统'><span>4.2.2 层次目录系统</span></h4><p><strong><span>层次目录系统（hierarchical directory system）</span></strong><span>可以有多个目录，组成层次结构。现在被广泛采用。</span></p><p><img src="./img/2022-04-29 18-15-54 的屏幕截图.png" style="zoom:50%;" /></p><h4 id='423-路径名'><span>4.2.3 路径名</span></h4><p><strong><span>绝对路径（absolute path）</span></strong><span>和</span><strong><span>相对路径（relative path）</span></strong></p><p><span>目录中有特殊的条目</span><code>.</code><span>指向当前目录，</span><code>..</code><span>指向父目录</span></p><h4 id='424-目录操作'><span>4.2.4 目录操作</span></h4><p><span>create, delete (only empty file can be deleted), opendir, closedir, readdir (return the next entry in an open directory in a standard format), rename, link (hard link, symbolic link), unlink</span></p><p><strong><span>关于链接</span></strong><span>：（将4.3.4节的实现细节合并整理了，虽然这里还没有引入inode，可以看到4.3.4再回来看这节内容）</span></p><ul><li><strong><span>硬链接（hard link）</span></strong><span>：删除任何其中一个文件，不会影响到另一个。使用</span><code>ln file1 file2</code><span>将</span><code>file2</code><span>硬链接到</span><code>file1</code><span>上，它们具有相同的inode编号（inode是一种结构体，存放了文件的属性和磁盘块地址，inode存放在磁盘上。inode可以通过</span><code>ls -i</code><span>查看，或者通通给过</span><code>stat filename</code><span>查看）。硬链接不能链接目录，这是因为目录的硬链接可能会打破文件系统目录的有向无环图结构，造成了你的父目录是你的子目录的怪事，导致一些遍历文件系统的命令出错。</span></li><li><strong><span>符号链接（symbolic link）</span></strong><span>：又称为</span><strong><span>软链接（soft link）</span></strong><span>，删除原始文件，会造成链接失效。相当于Windows下的快捷方式。使用指令</span><code>ln -s file1 file2</code><span>将</span><code>file2</code><span>符号链接到</span><code>file1</code><span>上。它们不具有相同的inode编号。软链接可以链接目录，这是因为系统知道软链接的文件类型不同于常规文件。下面是一个硬链接和软链接的示例：（最前面是inode号）</span></li></ul><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">❯ ls -al -i</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">总用量 16</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">5637007 drwxrwxr-x  2 Gu Wei Gu Wei 4096 4月  30 10:21 .</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">3276857 drwxr-xr-x 10 Gu Wei Gu Wei 4096 4月  30 10:21 ..</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">5637015 -rw-rw-r--  2 Gu Wei Gu Wei &nbsp; 33 4月  30 10:04 bb</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">5637015 -rw-rw-r--  2 Gu Wei Gu Wei &nbsp; 33 4月  30 10:04 hl</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">5637013 lrwxrwxrwx  1 Gu Wei Gu Wei &nbsp;  2 4月  30 10:04 sl -&gt; bb</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 159px;"></div><div class="CodeMirror-gutters" style="display: none; height: 159px;"></div></div></div></pre><p><span>关于上述结果需要强调一点。符号链接的文件实际存放的是路径名而不是inode号（倘若是inode号岂不是又和硬链接一样了），上例中sl文件大小为2字节，是因为bb文件名是两个字节；若将sl文件换一个目录下存放，sl就打不开了，这是因为软链接时bb文件采用了相对路径（这也是为什么软链接建议采用绝对路径）；不过即便bb文件用了绝对路径，如果将bb文件换了目录存放，那么sl又打不开了。</span></p><p><span>于是我们可以理解为什么符号链接会比硬链接花更多时间上开销。我们需要额外利用符号链接文件的inode号找到目标路径，然后逐步一层一层寻找，最终找到目标文件的inode号。在opstep的草率整理中，我曾经写到：</span></p><blockquote><p><span>调用open(&quot;/foo/bar&quot;,  O_RDONLY)，大体思路为：已知根目录“/&quot;的inode号，利用该inode号找到inode块，在该inode块中查找指向数据块的指针并以此找到数据块，数据块中包含根目录的内容，在目录中找到foo条目以及它的inode号，利用foo的inode号找到inode块，inode块中的指针找到目录数据块，在数据块找到bar的inode号，最后把bar的inode号读入内存并返回一个文件描述符。</span></p></blockquote><p><strong><span>关于unlink</span></strong><span>：</span></p><p><span>unlink使得一个目录条目被移除。当文件系统取消链接文件时，它检查inode号中的引用计数。该引用计数允许文件系统跟踪有多少不同的文件名已链接到这个inode，调用</span><code>unlink()</code><span>时，会删除文件名与给定inode号之间的“链接”，并减少引用计数。只有当引用计数达到零时，文件系统才会释放inode和相关数据块，从而真正删除该文件。UNIX下删除文件的操作实际上是通过unlink来实现的。</span></p><p><span>下图中创建了B文件到C文件的硬链接，可见创建硬链接后，inode的引用计数会增加，当C文件被删除后，引用计数会减小，B仍然可以访问该文件，即便所有者还是C。</span></p><p><img src="./img/mos4.3.4.png" style="zoom:50%;" /></p><h3 id='43-文件系统的实现'><span>4.3 文件系统的实现</span></h3><p><span>本节从实现者的角度探讨文件系统。注意到磁盘被我们看成多个连续的块组成。</span></p><h4 id='431-文件系统布局'><span>4.3.1 文件系统布局</span></h4><p><span>大部分磁盘都有一个或多个分区（partition）。每个分区有自己的文件系统。</span></p><p><img src="./img/mos4.3.1.png" style="zoom: 33%;" /></p><p><span>0号扇区被称作</span><strong><span>主引导记录（master boot record，MBR）</span></strong><span>，用来开机。MBR末尾是分区表（partition table），用来记录每个分区的起始和结束地址。其中一个分区被标记为活动分区。当开机时，BIOS读入并执行MBR，MBR会确定活动分区，读入活动分区的第一个块——</span><strong><span>引导块（boot block）</span></strong><span>。引导块中的程序将会加载该分区中的操作系统。</span></p><p><span>引导块后面是</span><strong><span>超级块（superblock）</span></strong><span>，它包含了文件系统的所有关键信息（用来表明文件系统类型的魔数，文件系统中的块数，管理信息等），并在刚开机或文件系统第一次接触时读入内存。</span></p><p><span>之后依次为</span><strong><span>空闲空间管理（free space management）</span></strong><span>——利用位图或者链表记录空闲块；</span><strong><span>inode</span></strong><span>——每个文件一个inode号，一种用来记录所有文件信息的数据结构；根目录、文件和目录。</span></p><h4 id='432-文件的实现'><span>4.3.2 文件的实现</span></h4><p><span>主要探讨如何记录文件存在哪些磁盘块里。后文中磁盘块也称为物理块，文件也看作是由连续的文件块组成。</span></p><p><strong><span>连续分配</span></strong></p><p><span>将每个文件作为一连串的数据块存储在磁盘上。只需要一个地址和长度，就可以知道文件存在哪里。</span></p><p><img src="./img/mos4.3.2.png" style="zoom: 33%;" /></p><p><span>优点：</span></p><ul><li><span>实现简单，记录每个文件用到的磁盘块只需要两个数字：第一块的磁盘地址和文件的块数</span></li><li><span>读操作性能好：单个操作中就可整个读出。只需要一次寻块，之后没有寻道和旋转延迟。</span></li></ul><p><span>缺点：</span></p><ul><li><span>删除文件后，产生外部碎片。如果想放入hole的话，需要预先知道文件的最终大小。</span></li><li><span>如果文件大小可变，会很糟糕</span></li></ul><p><span>应用场景：CD-ROM。所有文件都预先知道大小，并且不会改变。</span></p><p><strong><span>链表分配</span></strong></p><p><span>文件并不占据连续的物理块，每个物理块的第一个字作为指向下一个物理块的指针。块的其他部分存文件块数据。每个文件只需要记录一个物理块地址就可以访问了。</span></p><p><img src="./img/mos4.3.2-2.png" style="zoom:50%;" /></p><p><span>优点：</span></p><ul><li><span>无外部碎片</span></li><li><span>文件大小可任意改变</span></li></ul><p><span>缺点：</span></p><ul><li><span>随机访问缓慢（链表查找时间复杂度O(n)）</span></li><li><span>由于指针占据物理块的部分字节，使得文件块的大小很古怪</span></li></ul><p><strong><span>链表分配+FAT</span></strong></p><p><span>之前提及物理块最前面的指针使得文件块的大小很古怪，那么将这些指针单独拿出来存，就可以解决这个问题了。我们在内存中维护一个</span><strong><span>文件分配表（file allocation table, FAT）</span></strong><span>，记录下一个文件块用的物理块，-1表明该物理块是最后一个文件块。每一个文件只需要记录第一个物理块号，再通过查表就可以知道所有所用的物理块了。</span></p><p><img src="./img/mos4.3.2-3.png" style="zoom:50%;" /></p><p><span>额外优点：</span></p><ul><li><span>解决文件块大小古怪</span></li><li><span>随机访问时间变快。因为整个FAT都在内存中。</span></li></ul><p><span>缺点：</span></p><ul><li><span>每个物理块都要对应一个FAT条目。FAT会相当的大，占据过多内存。</span></li></ul><p><span>应用场景：MS-DOS采用的FAT-12，FAT-16，FAT-32文件系统。当年磁盘比较小哈。</span></p><p><strong><span>inode</span></strong></p><p><span>inode是一种数据结构，存放了文件属性和固定数量的磁盘块地址。为了大文件，可以记录包含附加磁盘地址的磁盘块的地址。每个文件只需要知道其inode号，再去在磁盘中找到对应的inode（见4.3.1节磁盘分区示意图的i节点），就可以知道文件对应的磁盘块地址以及文件属性。这是现代操作系统广泛采用的结构。</span></p><p><img src="./img/mos4.3.2-4.png" style="zoom:50%;" /></p><p><span>额外优点：</span></p><ul><li><span>只有当文件打开，其inode才在内存中。内存中的inode个数正比于可能要同时打开的最大文件个数，与磁盘自身大小无关。</span></li></ul><h4 id='433-目录的实现'><span>4.3.3 目录的实现</span></h4><p><span>目录的主要功能是把ASCII文件名映射成定位文件需要的信息。譬如连续分配的文件需要磁盘地址和文件长度；链表+FAT分配的需要第一个物理块号；inode实现的需要其inode号。这些信息都是由目录提供的。</span></p><p><span>下面讨论几个目录实现的细节。</span></p><p><strong><span>何处存放文件属性</span></strong></p><ul><li><span>inode中。目录项更短，只需要文件名和inode号。UNIX文件系统广泛采用。</span></li><li><span>目录项中。目录项包含文件名、文件属性的结构体和用来定位文件位置的信息。MS-DOS文件系统（FAT文件系统）采用。</span></li></ul><p><strong><span>可变长文件名的实现</span></strong></p><ul><li><p><span>给文件名分配固定长度，譬如225字符。但是文件名大多不会这么长，会浪费目录空间。</span></p></li><li><p><span>可变长文件名，如下图两种实现</span></p><p><img src="./img/mos4.3.3.jpg" style="zoom:15%;" /></p><p><span>前者移除目录项后会产生外部碎片。后者需要额外管理一个堆。此外两者都可能使得一个目录项分布在多个页面上，读取时造成缺页中断。</span></p></li></ul><p><strong><span>快速查找目录中的文件</span></strong></p><p><span>当目录很大时，顺序查找可能性能不佳。有两个小手段：</span></p><ul><li><span>哈希表</span></li><li><span>把查找结果放入高速缓存，当然这建立在可能不存在的局部性上。</span></li></ul><h4 id='434-共享文件'><span>4.3.4 共享文件</span></h4><p><span>参见4.2.4节。</span></p><h4 id='435-日志结构文件系统'><span>4.3.5 日志结构文件系统</span></h4><p><strong><span>日志结构文件系统（log-structured file system, LSF）</span></strong><span>的提出基于以下动机：</span></p><ul><li><span>内存大小不断增长。磁盘流量越来越多由写入组成。</span></li><li><span>随机I/O性能于顺序I/O性能之间存在巨大差距，且不断扩大。</span></li><li><span>现有文件系统在许多常见工作负载上表现不佳。有大量的随机I/O写入。</span></li></ul><p><span>于是20世纪90年代早期，伯克利小组提出了LSF，希望充分利用磁盘的顺序写入带宽。其核心思想是：首先将所有更新（inode、目录块、数据块）缓存在内存段。当段（segment）已经满时，它会在一次长时间的顺序传输中写入磁盘。将磁盘看作是一个巨大的日志（log），每次写入在日志的最后。示意图如下：</span></p><p><img src="./img/2022-04-30 20-08-30 的屏幕截图.png" style="zoom: 67%;" /></p><p><span>虽然测试表明LSF比UNIX有更好的读写表现，但是由于与现有的文件系统不相容，没有被广泛采用。</span></p><p><span>这种设计也引入了额外的问题。</span></p><p><strong><span>如何查找inode</span></strong></p><p><span>LSF下inode不再保存在磁盘的固定位置。为了找到inode，我们需要维护inode map。inode map将inode号作为输入，并生成最新版本的inode磁盘地址。那inode map又放在哪里呢？为了顺序读写，inode map就放在所有其他新信息的位置旁边。可是又怎么找到inode map呢？LFS的磁盘上有一个固定的位置，称为检查点区域（checkpoint region），指向了最新的inode map的位置。</span></p><p><span>从磁盘读取文件的过程为：根据磁盘的检查点区域，读取整个inode map并存入内存。每当给出inode号时，LFS在inode map找到相应其在磁盘上的地址，并读入最新版本的inode。之后根据inode中磁盘块地址读取数据即可。</span></p><p><strong><span>如何做垃圾清理</span></strong></p><p><span>由于LSF总是将最新版本的文件写入磁盘上的新位置，所以磁盘上会分散旧版本的文件结构。基本清理过程如下：LSF清理程序定期读入许多旧的（部分使用的）段，确定哪些块在这些段中存在，然后写出一组新的段，只包含其中活着的块，从而释放旧块用于写入。具体来说，清理程序读取M个现有段，将其内容打包到N个新段（其中N&lt;M），然后把这N个段写入磁盘的新位置，释放旧的M段，文件系统可以使用它们进行后续写入。</span></p><p><span>如何确定块的死活：It starts out by reading the summary of the first segment in the log to see which inodes and files are there. It then checks the current inode map to see if the inodes are still current and file blocks are still in use.</span></p><p><em><span>更多细节可以参考ostep第43章</span></em></p><h4 id='436-日志文件系统'><span>4.3.6 日志文件系统</span></h4><p><strong><span>日志文件系统（journaling file system）</span></strong><span>的基本思想是：保存一个用于记录系统下一步要做什么的日志，如果系统在做计划好的工作前崩溃了，通过查看日志就可以恢复之前尚未完成的工作。微软的NTFS和Linux的ext3、ext4都采用了日志。具体细节在4.4.3节讨论。</span></p><h4 id='437-虚拟文件系统'><span>4.3.7 虚拟文件系统</span></h4><p><span>一个操作系统中也可能有不同的文件系统：</span></p><ul><li><span>Windows通过制定不同的盘符来处理文件系统，比如C:, D:等。进程打开文件时，盘符是隐式的，操作系统知道向哪个文件系统传递请求。</span></li><li><span>UNIX将多个文件系统整合到一个统一的结构中。不同的目录可以有不同的文件系统。</span></li></ul><p><span>下面讨论</span><strong><span>虚拟文件系统（virtual file system，VFS）</span></strong><span>，大部分UNIX使用VFS的概念来将多个文件系统整合到一个统一的结构中。</span></p><p><span>VFS提供两层接口。上层给用户进程提供POSIX接口，下层给文件系统提供</span><strong><span>VFS interface</span></strong><span>。每个文件系统需要提供VFS要求的函数调用。如下图：</span></p><p><img src="./img/mos4.3.7.png" style="zoom:67%;" /></p><p><span>具体细节不再展开。</span></p><h3 id='44-文件系统的管理和优化'><span>4.4 文件系统的管理和优化</span></h3><h4 id='441-磁盘空间管理'><span>4.4.1 磁盘空间管理</span></h4><p><span>我们已经看到了存储n字节的文件有两种策略：</span></p><ul><li><span>分配n字节的连续磁盘空间。文件扩大时，需要在磁盘上移动文件。有外部碎片等毛病。</span></li><li><span>文件系统分成很多个块，这些块不用在磁盘上连续。更被现代操作系统广泛采用。</span></li></ul><p><span>下面讨论一些关于分块的更多细节</span></p><p><strong><span>1）块大小</span></strong></p><ul><li><span>块过大：小文件来说浪费空间</span></li><li><span>块过小：分布更分散，寻道时间增加</span></li></ul><p><strong><span>2）记录空闲块</span></strong></p><p><span>对4.3.1节空闲空间管理（free-space management）的进一步阐释。</span></p><ul><li><strong><span>空闲链表（free list）</span></strong><span>：由多个磁盘块组成链表，每个磁盘块存放空闲磁盘块号（故这些磁盘块称为空闲磁盘块）。一个1TB的磁盘，若采用1KB的块和32位的茨磁盘块号，需要大约4百万个1KB块存链表。</span></li><li><strong><span>位图（bitmap）</span></strong><span>：每一个块用一位表示是否空闲。一个1TB的磁盘，若采用1KB的块，需要10亿位大小的位图，也就是约130000个1KB块存位图。比链表的实现所占的空间更小。</span></li></ul><p><img src="./img/mos4.4.1.png" style="zoom: 50%;" /></p><p><strong><span>链表方案的一种变体</span></strong></p><p><span>如果空闲块倾向于连续的长的分块，可以用空闲磁盘块号+长度来记录，从而降低所占空间。但是如果磁盘碎片较多，上述表达效果就不一定好了。</span></p><p><strong><span>关于加载空闲链表到内存</span></strong></p><p><span>并不会把整个空闲链表加载到内存，只需要加载一个空闲磁盘块就行了。下图中为了减少不必要的IO，图a增加三个空闲块后将变为图c，而不是图b。</span></p><p><img src="./img/mos4.4.1-2.png" style="zoom:50%;" /></p><p><strong><span>3）磁盘配额</span></strong></p><p><span>防止用户占有过多的磁盘空间，多用户操作系统经常提供一个机制来强制执行磁盘配额。主要思想是：系统管理员给用户拥有的文件和块的最大数量，并由操作系统确保不超过限额。</span></p><h4 id='442-文件系统备份'><span>4.4.2 文件系统备份</span></h4><p><strong><span>转储（dump）</span></strong><span>就当作是</span><strong><span>备份（back up）</span></strong><span>吧。可能有区别，但是不清楚。</span></p><p><strong><span>1）为何要备份</span></strong></p><ul><li><span>从意外灾难中恢复：磁盘崩溃、火灾、洪水等</span></li><li><span>从愚蠢操作中恢复：不小心删除了文件。为此设计了回收站。</span></li></ul><p><strong><span>2）备份到哪里</span></strong></p><p><span>另一块磁盘或者磁带等。</span></p><p><strong><span>3）备份全部还是部分</span></strong></p><p><span>部分。对于可从生产商网站或光盘安装的文件、temporary文件、特殊文件（IO设备）无需备份</span></p><p><strong><span>4）增量转储（incremental dump）</span></strong></p><p><span>无需备份上次备份已经备份的文件，只需备份新的和被修改过的文件。</span></p><p><strong><span>5）备份前可以压缩</span></strong></p><p><span>但是一个备份磁带上的坏点可能会破坏解压算法，使得文件乃至整个磁带不可读。</span></p><p><strong><span>6）备份活跃文档</span></strong></p><p><span>备份过程中添加、修改、删除文件和目录会导致文件系统的不一致性。所以建议脱机时备份，或者备份关键时刻快照。</span></p><p><strong><span>7）非技术问题</span></strong></p><p><span>你把公司的机密资料备份在磁盘上，并随意扔在桌子上，然后去楼下买杯咖啡。结果你的备份磁盘就被偷了。</span></p><p><strong><span>8）如何备份</span></strong></p><ul><li><strong><span>物理转储（physical dump）</span></strong><span>：从磁盘的第0块开始，一直复制，直到复制完。注意：未使用的磁盘块无需备份，于是备份磁盘的第k块不等于被备份的磁盘上的第k块，需要记录关系；坏块不存储。优点：简单快速。劣势：无法跳过特定目录、实现增量转储、备份特定文件等。并不被广泛采用。</span></li><li><strong><span>逻辑转储（logical dump）</span></strong><span>：从一个或者几个制定的目录开始，递归地转储其自给定基准日期后有所更改的文件或目录。常见的转储方案。书上给出了一个基本算法，就是多次遍历文件树，对目录和文件进行转储。具体细节不再展开。对于链接文件只要备份和恢复一次。</span></li></ul><h4 id='443-崩溃一致性'><span>4.4.3 崩溃一致性</span></h4><p><em><span>本章参考了ostep第42章，更多细节可以看ostep</span></em></p><p><span>如果某个操作的完成有多个步骤，其中某一步做完后系统崩溃或断电，则会发生</span><strong><span>不一致（inconsistent）</span></strong><span>的情况。这个问题称为</span><strong><span>崩溃一致性问题（crash-consistency problem）</span></strong><span>。</span></p><p><strong><span>考虑更新文件的例子</span></strong></p><p><span>考虑写入需要三步：修改文件的inode、写入文件的data块，更新位图（如果需要更多数据块的话）。</span></p><p><span>其中的任两步操作之间都可能会系统崩溃，例如：</span></p><ul><li><span>只写入了数据块：对于文件系统一致性毫无影响，仿佛写入没有发生过一样。只不过用户体验不好。</span></li><li><span>只写入了inode更新：由于数据块没有写入，因此如果根据inode读数据会读到垃圾</span></li><li><span>只写入了bitmap更新：问题很大，空间实际上没有被使用，但是显示已分配，故会导致空间泄露（并且如果不做处理，则会永远永远泄露，因为磁盘是长久存储）。</span></li><li><span>等等（两次成功写入，最后一次失败）</span></li></ul><p><strong><span>解决方案1：fsck</span></strong></p><p><strong><span>fsck（file system checker）</span></strong><span>是一个UNIX工具，不处理不一致的发生，而是在发生后修复他们。它无法解决所有问题（例如只写入了位图和inode但是没有写入数据，文件系统看上去一致，但是数据块是垃圾），唯一的目标是让文件系统内部一致。</span></p><p><span>以下是fsck的基本总结：</span></p><ul><li><span>超级块检查：检查超级块是否合理</span></li><li><span>空闲块检查：扫描inode、间接块、双重间接块等等，以这些信息去更新bitmap（也就是说，比起bitmap，系统更信任inode的内容）</span></li><li><span>inode状态：如果存在问题并且不易修复，则fsck直接清除该inode，并且更新相应的inode位图</span></li><li><span>inode链接：检索引用计数，如果计算的计数与inode中的计数不一样，则更新inode中的计数；如果没有目录引用inode，则将该文件移动到lost + found目录</span></li><li><span>检查重复：如果两个inode引用同一个数据块，则会清除明显不对的inode，或者复制一份</span></li><li><span>坏块检查：扫描指针，如果指针显然不正确，则会删除该指针</span></li><li><span>目录检查：检查每个目录是否有</span><code>.</code><span>和</span><code>..</code><span>，引用的每个inode是否已经分配等等</span></li></ul><p><span>fsck问题：太慢了。出问题的一般都是少数文件，因此每次都扫描所有文件的代价太大了</span></p><p><strong><span>解决方案2：日志</span></strong><span>（我只摘取了部分内容）</span></p><p><span>思想是：每次写磁盘之前，都先写</span><strong><span>日志（journaling）</span></strong><span>，崩溃后可以从日志中恢复。日志也称做</span><strong><span>预写日志（write-ahead logging）</span></strong><span>。许多现代文件系统（ext3、ext4、NTFS等）都使用了这个想法。下面看具体实现。</span></p><p><strong><span>日志放在哪</span></strong><span>：可以放在磁盘上超级块的旁边</span></p><p><strong><span>数据日志</span></strong></p><ul><li><p><span>日志类型（和转储类似）</span></p><ul><li><span>物理日志：日志内容即写入的数据内容。为表述简单，我们只考虑物理日志。</span></li><li><span>逻辑日志：日志内容指引数据如何修改。可以节省空间，但是更复杂</span></li></ul></li><li><p><span>操作</span></p><ol start='' ><li><span>每次写磁盘数据之前，都先写TxB（起始标识）、待写数据（inode、位图、数据块）、TxE（结束标识）进磁盘日志区</span></li><li><span>写完TxE后，将数据写入磁盘数据块（这个步骤称为加检查点）</span></li></ol></li><li><p><span>恢复</span></p><ul><li><span>如果日志不完整（没有TxE），则跳过该日志。用户写入的新数据丢失，但是一致性没有被破坏</span></li><li><span>如果日志完整，则重做日志。即使该事务已经执行完毕，重做也不影响，仅仅是进行了冗余操作。由于崩溃不常发生，故可以接受。</span></li></ul></li></ul><p><strong><span>元数据日志</span></strong></p><p><span>上述数据日志，在每次写入磁盘时，需要先写入日志，从而使得写入流量加倍。事实上只需要采用特定的写入顺序，文件的数据块不必写入日志。具体步骤如下：</span></p><ol start='' ><li><span>数据写入磁盘</span></li><li><span>日志写入开始块和元数据</span></li><li><span>日志提交，将事物提交块写入日志，等待写完成</span></li><li><span>加检查点元数据</span></li><li><span>释放已经加检查点的日志</span></li></ol><p><span>其中1和2顺序不限定，但是3必须在1、2都完成后再做  </span></p><h4 id='444-文件系统性能'><span>4.4.4 文件系统性能</span></h4><p><span>下面讨论几种提高磁盘访问速度。</span></p><p><strong><span>1）高速缓存</span></strong></p><p><span>在内存中为磁盘盘块设置的一个缓冲区，在缓冲区中保存了某些盘块的副本。快速查找缓冲区是否有目标盘块的副本可用哈希表。缓存满了，用页面置换算法就行了。</span></p><p><strong><span>2）块提前读</span></strong></p><p><span>不就是预取（prefetching）吗</span></p><p><strong><span>3）减少磁盘臂运动</span></strong></p><p><span>之前我们一直假定inode放在磁盘最开始的块中（如下图a），这导致访问inode和相应数据块需要大量的寻道时间。一些现代文件系统（ext2，ext3）将磁盘划分为一些分组，称为</span><strong><span>柱面组（cylinder group）</span></strong><span>或者</span><strong><span>块组（block group）</span></strong><span>。同一组有多个文件，有自己的超级块、inode和空闲内存管理部分。这可以减少寻道时间。</span></p><p><span>不过对于SSD，就没有这种问题了。</span></p><p><img src="./img/mos4.4.4.png" style="zoom:40%;" /></p><h3 id='45-案例'><span>4.5 案例</span></h3><p><span>介绍了MS-DOS系统的</span><strong><span>FAT-12,FAT-16和FAT-32</span></strong><span>文件系统（磁盘地址分别为12、16和32位），</span><strong><span>UNIX V7</span></strong><span>文件系统，以及CD-ROM的</span><strong><span>ISO 9660</span></strong><span>文件系统及其</span><strong><span>Rock Ridge</span></strong><span>扩展、</span><strong><span>Joliet</span></strong><span>扩展。主要关心了目录项的设计，我也没有认真看😀</span></p><hr /><div style="page-break-after: always;"></div> <h2 id='五输入输出'><span>五、输入/输出</span></h2><p><span>操作系统需要管理所有计算机的输入输出设备。需要给I/O设备发送指令、捕捉中断和处理错误，还需要给I/O设备和其余系统之间提供一个简单易用的接口。本章从I/O硬件出发，然后探讨I/O软件，最后研究具体的几个IO设备。限于本人时间，主要粗略整理了IO硬件、IO软件和磁盘三个部分，其他内容一笔代过。整章的读+整理只用了两天，可能理解程度不如其他章节。</span></p><h3 id='51-io硬件原理'><span>5.1 I/O硬件原理</span></h3><p><span>划定讨论范围：We are concerned with programming I/O devices, not designing, building, or maintaining them, so our interest is in how the hardware is programmed, not how it works inside.</span></p><h4 id='511-io设备'><span>5.1.1 I/O设备</span></h4><p><span>可以分成两类：</span></p><ul><li><strong><span>block device</span></strong><span>：以固定大小的块（512～65536 bytes）存储信息，每个块有自己的地址，每次传送以块为单位。例子：磁盘</span></li><li><strong><span>character device</span></strong><span>：以字符串的信息接受传递信息，没有块的概念。例子：打印机、鼠标</span></li></ul><p><span>但是分类并不是完美的。譬如时钟就不属于其中任意一类。</span></p><h4 id='512-设备控制器'><span>5.1.2 设备控制器</span></h4><p><span>I/O unit =  mechanical component + electronic component。其中机械部分就是设备自身，电子部分称为</span><strong><span>设备控制器（device controller）</span></strong><span>或者</span><strong><span>适配器（adapter）</span></strong><span>。通常设备控制器是主板上的芯片或者一个可以插入PCIe扩展槽的印刷电路板。如下图：</span></p><p><img src="./img/mos5.1.2.jpg" style="zoom:20%;" /></p><p><span>控制器上可以有多个接口，只要满足相应协议的设备都能连接上。磁盘控制器的工作是将读取的比特串转化为字节块，并做一些必要的错误检查和修正。LCD显示器控制器的工作是将输入的字符转换为信号，来修改屏幕上的相应像素。</span></p><h4 id='513-io映射'><span>5.1.3 I/O映射</span></h4><p><span>每个设备控制器有一些控制寄存器（control register）来和CPU交流。此外，许多设备还有自己的数据缓冲区，允许操作系统读写，譬如显存。CPU如何和这些控制寄存器和数据缓冲区交流呢？有三种I/O映射的方法：</span></p><ul><li><strong><span>分离式IO（isolated I/O）</span></strong><span>：每个控制寄存器有自己的</span><strong><span>IO端口（IO port）</span></strong><span>号，并组成了</span><strong><span>IO端口空间（I/O port space）</span></strong><span>，与内存地址空间独立；需要IO和内存选择控制线；需要特别的IO指令（譬如</span><code>IN REG, PORT</code><span>将端口数据读入寄存器，</span><code>OUT PORT, REG</code><span>将寄存器数据读到端口。指令不再是</span><code>MOV</code><span>。REG</span><code>是通用寄存器，</code><span>PORT`是IO设备的控制寄存器）</span></li><li><strong><span>内存映射IO（memory-mapped I/O）</span></strong><span>：将所有控制寄存器映射到内存地址空间，IO设备和内存共享地址空间；IO读写看起来内存读写；不需要为IO单独设计指令</span></li><li><span>混合方案（hybrid scheme）：上面两种IO映射共存。x86就使用这种方案。</span></li></ul><p><img src="./img/mos5.1.3.jpg" style="zoom: 50%;" /></p><p><strong><span>如何工作</span></strong><span>：当CPU想要读取数据时，先把地址放在地址总线，再设置总线控制线的READ信号。如果是分离式IO，需要设置IO和内存选择控制线；如果是内存映射IO，IO设备和内存都需要读取地址，并判断该地址在不在自己的范围内（由于内存和IO设备的地址不相交，所以不会产生冲突）。</span></p><p><strong><span>优劣分析</span></strong><span>（以内存映射为例）：</span></p><ul><li><p><span>优势：</span></p><ul><li><span>设备控制寄存器就像是内存中的变量，可以由C程序访问。而分离式IO需要单独的指令访问IO，在C语言中无相应的语法，需要汇编程序来访问分离式IO。</span></li><li><span>限制用户访问IO设备变得简单。只需将包含设备控制寄存器的内存不放入（或部分放入）用户的虚拟地址空间即可。</span></li><li><span>无需更多的指令。那些原来可以访问内存的指令仍然可以访问控制寄存器。可以减少程序指令数（譬如</span><code>TEST PORT</code><span>=</span><code>IN REG PORT</code><span>+</span><code>TEST REG</code><span>，少了一个指令）</span></li></ul></li><li><p><span>劣势：</span></p><ul><li><span>不可以缓存控制寄存器，每次应当直接对IO设备进行读写。否则当IO设备状态改变时，CPU将从缓存中得到过时的数据。在3.3.1节我们看到页表项中有caching disabled bit来禁止缓存控制寄存器。可见这会引入一些硬件和软件上的复杂性。</span></li><li><span>当下个人电脑倾向于为CPU和内存设计高速专用的内存总线。这使得传送在内存总线上的数据将无法到达IO设备。为此可以：法一，先将所有内存访问传送到内存，如果内存无法响应，则将该内存访问通过其他总线传送到IO设备；法二：在内存总线放一个嗅探器，把可能是IO设备的地址传送到IO设备；法三：内存控制器知道IO设备的地址，把这些地址传送到IO设备。</span></li></ul></li></ul><h4 id='514-直接存储器存取'><span>5.1.4 直接存储器存取</span></h4><p><strong><span>直接存储器存取（direct memory access, DMA）</span></strong><span>使得IO设备可以直接和内存进行数据传输。CPU只需要告诉DMA控制器内存地址信息、传送数据大小、IO端口号、传送方向、传送单元大小（one byte/word at a time）等。DMA控制器通常集成在主板上。</span></p><p><span>当没有DMA时，磁盘读取过程类似为：磁盘控制器读取目标磁盘块，将比特流写入自己内部的缓冲区；磁盘控制器计算校验和，确认没有错误发生；磁盘控制器产生中断；操作系统一个字一个字（或者一个字节一个字节）读取磁盘控制器缓冲区的数据，并写入主存。</span></p><p><span>当有DMA时，CPU先编程DMA处理器，并通知磁盘控制器在缓冲区中准备好相应的数据并作校验检查（step1），当磁盘控制器缓冲区数据准备好后，DMA开始干活；DMA控制器通过总线向磁盘控制器发送读取请求（step2）；磁盘控制器将数据写入内存（step3）；磁盘控制器发送Ack信号给DMA控制器（step4）；DMA控制器增加地址寄存器的值、减少计数寄存器的值，如果计数不为0，重复步骤2～4；DMA控制器发送中断给CPU，告知所有传送已经结束。如下图</span></p><p><img src="./img/mos5.1.4.jpg" style="zoom:50%;" /></p><p><span>一些复杂的DMA控制器可以有多组寄存器，同时处理多个传输。</span></p><p><span>DMA控制器可以以字为单位传送数据，也可以以块为单位传送数据。前者会偷总线周期（</span><strong><span>cycle stealing</span></strong><span>）——在DMA控制器使用总线时，CPU无法使用总线。后者称为</span><strong><span>burst mode</span></strong><span>，减少获取总线等额外耗时的同时也会造成CPU大段时间无法使用总线。</span></p><p><span>之前我们讨论的方案是将磁盘控制器的数据直接传送到主存，这称为</span><strong><span>fly-by mode</span></strong><span>。但其实也可以先将数据传送到DMA控制器，再从DMA控制器传送到主存，这使得IO设备之间传送数据变得简单，但也引入了额外的总线周期。</span></p><p><span>大部分DMA控制器使用的是物理地址。CPU内部的MMU先将虚拟地址翻译为物理地址，再送到DMA中。</span></p><p><span>并不是所有计算机都使用DMA。由于CPU比DMA控制器快很多，有的时候CPU需要等待DMA，而自己无事可做。</span></p><h4 id='515-重温中断'><span>5.1.5 重温中断</span></h4><p><span>大部分内容已经在第二章开头以及2.1.6节提及。这里介绍</span><strong><span>精确中断（precise interrupt）</span></strong><span>和</span><strong><span>不精确中断（imprecise interrupt）</span></strong><span>。精准中断需要满足：</span></p><ul><li><span>产生中断的指令前的所有指令都已完成</span></li><li><span>产生中断的指令包括后续指令没有改变任何机器状态。</span></li></ul><p><img src="./img/mos5.1.5.jpg" style="zoom:20%;" /></p><p><span>在计组整理的4.3节有一个具体的五级流水精确中断的实现，这里则更从理论上看待问题。</span></p><p><span>不精确中断给操作系统设计者带来了麻烦。当采用不精确中断时，机器将把大量的内部状态写入栈，让操作系统自己搞清楚发生了什么。这使得处理中断很缓慢。精确中断则给CPU设计者带来了麻烦。超标量处理器乱序执行指令使得后头的指令反而先完成。如何避免后续指令改变机器状态，给CPU设计者带来了挑战。</span></p><h3 id='52-io软件原理'><span>5.2 I/O软件原理</span></h3><h4 id='521-io软件的目标'><span>5.2.1 I/O软件的目标</span></h4><p><span>目标有：</span></p><ul><li><strong><span>device independence</span></strong><span>: We should be able to write programs that can access any I/O device without having to specify the device in advance.</span></li><li><strong><span>uniform naming</span></strong><span>: The name fo a file or a device should simply be a string or an integer and not depend on the device in any way. e.g. by a path name, just like a file</span></li><li><strong><span>error handling</span></strong><span>: Errors should be handled as close to the hardware as possible. In many cases, error recovery can be done transparently at a low level without the upper levels even knowing about the error.</span></li><li><strong><span>synchronous</span></strong><span> (blocking) vs. </span><strong><span>asynchronous</span></strong><span> (interrupt-driven) transfer</span></li><li><strong><span>buffering</span></strong></li><li><strong><span>sharable vs. dedicated devices</span></strong><span>: e.g. Disks can be used by many users at the same time, while printers have to dedicated to a single user until that user is finished.</span></li></ul><h4 id='522-程序控制io'><span>5.2.2 程序控制I/O</span></h4><p><span>5.2.2～5.2.4考虑一个无缓冲区的打印机打印问题。每次传送一个字符给打印机，打印完后，再传送下一个字符。</span></p><p><strong><span>程序控制I/O（programmed IO）</span></strong><span>下，I/O设备不会通知CPU它已经完成任务了，CPU需要</span><strong><span>轮询（polling）</span></strong><span>或者</span><strong><span>忙等（busy waiting）</span></strong><span>，不断查看IO设备状态。实现起来简单，但是CPU会浪费时间在检查IO设备状态上。</span></p><h4 id='523-中断驱动io'><span>5.2.3 中断驱动I/O</span></h4><p><strong><span>中断驱动I/O（interrupt-driven I/O）</span></strong><span>下，I/O设备在任务完成后会产生中断通知CPU。CPU不必忙等IO设备，可以自己去做其他的任务。但在本例中，打印会产生大量的中断（一个字符一个中断），也降低了CPU的性能。</span></p><h4 id='524-使用dma的io'><span>5.2.4 使用DMA的I/O</span></h4><p><span>把任务交给DMA，当DMA完成后，使用一个中断通知CPU。DMA本质上是程序控制I/O。整个工作CPU只会被中断一次。即便存在CPU需要等待DMA而自己无事可做的可能性，但是通常来说DMA很优秀。</span></p><h3 id='53-io软件层次'><span>5.3 I/O软件层次</span></h3><p><span>如图所示有四层：</span></p><p><img src="./img/mos5.3.jpg" style="zoom:18%;" /></p><h4 id='531-中断处理程序'><span>5.3.1 中断处理程序</span></h4><p><span>之所以将中断处理程序放在最底层，是想让操作系统中尽可能少的部分知道中断。当中断发生后，设备驱动程序将被阻塞，中断处理程序开始运行。</span></p><h4 id='532-设备驱动程序'><span>5.3.2 设备驱动程序</span></h4><p><span>IO设备需要一些device-specific代码来控制，这些代码称为</span><strong><span>驱动（driver）</span></strong><span>。一般驱动程序都是由设备生产商写的，不同的操作系统需要不同的驱动程序。驱动程序一般在内核。逻辑如下图：</span></p><p><img src="./img/mos5.3.2.jpg" style="zoom:12%;" /></p><p><span>以前有新的驱动就重新编译一下内核。但是随着个人电脑时代来临，普通用户没有能力重新编译链接内核，也没有源码，驱动通常是通过在执行时动态加载到内核的。</span></p><p><span>驱动主要是把来自与设备无关I/O软件的抽象的读写操作，转换为对IO设备的寄存器设置。此外驱动会将多个请求被放入队列等待、给设备控制器发送一系列指令、检查一些设备控制器的返回值等等。</span></p><h4 id='533-与设备无关的io软件'><span>5.3.3 与设备无关的I/O软件</span></h4><p><span>The basic function of the device-independent software is to perform the I/O functions that are common to all devices and to provide a uniform interface to the user-level software. 具体包含：</span></p><ul><li><span>uniform interfacing for device drivers: make all I/O devices and drivers look more or less the same</span></li><li><span>buffering: 单缓冲区，双缓冲区，环形缓冲区</span></li><li><span>error reporting</span></li><li><span>allocating and releasing dedicated devices</span></li><li><span>providing a device-independent block size</span></li></ul><p><em><span>更多细节可以看书，我其实看的不是很懂这里</span></em></p><h4 id='534-用户空间的io软件'><span>5.3.4 用户空间的I/O软件</span></h4><p><span>一般而言，大部分的 I/O 软件都在操作系统内部，但仍有一小部分在用户层，包括系统调用（由库函数实现，譬如read、write函数），以及完全运行于内核之外的假脱机（spooling）系统等。假脱机已经在6.5.1和2.3.1讲过了。</span></p><h3 id='54-磁盘'><span>5.4 磁盘</span></h3><p><span>磁盘的基本常识已经在计组整理的5.1.3节提及了。所有现代的磁盘都支持</span><strong><span>逻辑区块地址（logical block addressing）</span></strong><span>，即每个扇区依次从0开始编码，不再考虑磁盘的几何位置。</span></p><h4 id='541-raid'><span>5.4.1 RAID</span></h4><p><strong><span>廉价冗余磁盘阵列（redundant array of inexpensive disks, RAID）</span></strong><span>使用多个磁盘一起构建了更快更大更可靠的磁盘系统。在操作系统看来RAID就像一个大磁盘，操作系统无需任何的修改就可以使用RAID。下面依次介绍RAID level 0 ～ RAID level 6.</span></p><ul><li><span>level 0 条带化：本书上说一个</span><strong><span>条带（strip）</span></strong><span>由k个扇区组成，扇区0～k-1组成条带0，k～2k-1组成条带1，按照如图所示的方法在多个磁盘上分配。但是ostep上说以轮转的方式将磁盘阵列的块分布在磁盘上，同一行中的块称为条带（譬如块0～3依次在四个磁盘上，这四个块称为一个条带），和本书略有出入。条带化对于大读写性能很好，可以充分利用多个磁盘的并行性；容量也很好，每个磁盘都存了独一无二的数据。但是可靠性很差，任何磁盘故障都会导致数据丢失。没有冗余磁盘，从这个角度来看RAID-0并不是一个真正的RAID。</span></li><li><span>level 1 镜像：复制每个磁盘，图中有四个原始磁盘和四个备份磁盘（阴影）。RAID-1还可以分成RAID-10和RAID-01，RAID-10先镜像后条带，RAID-01先条带后镜像。图中所示的是RAID-01，若以1和5，2和6，3和7，4和8这样顺序摆放，就成为RAID-10. 该例中写入性能和RAID-0一致（原始磁盘和备份磁盘的写入并行进行），但是读取性能可以翻倍，因为数据可以分成两半一起从两个磁盘读取。</span></li><li><span>level 2：以字或者字节为单位读写。本例中七个磁盘每次传送一位，其中bit1、2、4是奇偶校验位，这七位组成了Hamming code。任何一位出错，都可以利用Hamming code解决。缺点是所有的磁盘需要旋转同步（要求大量控制单元），每传一位数据就要计算一次Hamming校验和。</span></li><li><span>level 3：只使用一个奇偶校验位（偶数个1，返回0；奇数个1，返回1. 其实就是进行异或运算。包括校验位后一共有偶数个1）。初看来只能检查出错误，不能改正错误。但如果错误的位的位置知道的话，就可以改正错误了。</span></li><li><span>level 4：该例中，P0-3是strip0～strip3的异或结果。允许一个磁盘故障。每次写入都要更新存放奇偶校验的磁盘，阻碍了写入的并行性。该问题称为基于奇偶校验的RAID的小写入问题（small-write problem）。</span></li><li><span>level 5：针对RAID-4的小写入问题，将奇偶校验结果按照如同所示分配。</span></li><li><span>level 6：备份奇偶校验结果。如图所示。</span></li></ul><p><img src="./img/mos5.4.1.jpg" referrerpolicy="no-referrer"></p><h4 id='542-磁盘格式化'><span>5.4.2 磁盘格式化</span></h4><p><span>磁盘扇区包含：</span></p><ul><li><span>preamble（前导码）：由一些特定位开始，来允许硬件识别扇区的开始。包含柱面和扇区号等其他信息。</span></li><li><span>data：数据部分的大小由低级格式化程序来确定。大部分磁盘使用 512 字节的扇区。</span><em><span>（额，所以512字节报不包含preamble和ECC呢）</span></em></li><li><span>ECC：error correcting code，用来帮助从读取错误中恢复。ECC 大小的设计标准取决于设计者愿意牺牲多少磁盘空间来提高可靠性，16字节大并不少见。</span></li></ul><p><span>除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区。</span></p><p><span>低级格式化后的每个 0 扇区的位置都和前一个磁道存在偏移，这种方式又被称为</span><strong><span>柱面斜进(cylinder skew)</span></strong><span>。之所以采用这种方式是为了提高程序的运行性能。可以这样想，磁盘在转动的过程中会经由磁头来读取扇区信息，在读取内侧一圈扇区数据后，磁头会进行向外侧磁道的寻址操作，寻址操作的同时磁盘在继续转动，如果不采用这种方式，可能刚好磁头寻址到外侧，0 号扇区已经转过了磁头，所以需要旋转一圈才能等到它继续读取，通过柱面斜进的方式可以消除这一问题。不只有柱面存在斜进，切换磁头也会存在斜进，但是</span><strong><span>磁头斜进(head skew)</span></strong><span>比较小。</span></p><p><img src="./img/mos5.4.2.webp" style="zoom:33%;" /></p><p><span>低级格式化后，磁盘容量会减少。这是因为有前导码、扇区间间隙、ECC、备用扇区等。低级格式化后，磁盘完成了分区，拥有了主引导记录和分区表。之后还要对每个分区分别执行一次高级格式化，这一操作要设置一个引导块、空闲存储管理（采用位图或者是空闲列表）、根目录和空文件系统。最后形成了4.3.1节所示的模样。</span></p><h4 id='543-磁盘臂调度算法'><span>5.4.3 磁盘臂调度算法</span></h4><p><span>一般情况下，影响磁盘快读写的时间由下面几个因素决定</span></p><ul><li><strong><span>寻道时间（seek time）</span></strong><span>：将磁盘臂移动到目标柱面的时间</span></li><li><strong><span>旋转延迟（rotational delay）</span></strong><span>：目标扇区旋转到磁头下所需的时间</span></li><li><span>实际数据的传送时间</span></li></ul><p><span>通常寻道时间比重远大于其他两者，下面讨论磁盘臂调度算法。考虑有0-199个柱面，请求队列为98,183,37, 122, 14, 124, 65, 67. 磁头现在在53号柱面。</span></p><p><strong><span>FCFS</span></strong><span>（first come first serve）</span></p><p><img src="./img/2022-05-05 21-26-28 的屏幕截图.png" style="zoom: 67%;" /></p><p><strong><span>SSTF</span></strong><span>（shortest seek time first）</span></p><p><img src="./img/2022-05-05 21-29-34 的屏幕截图.png" style="zoom:67%;" /></p><p><strong><span>SCAN</span></strong><span>：The disk arm starts at one end of the disk, and moves toward the other end, servicing requests until it gets to the other end of the disk, where the head movement is reversed and service continues. 注意到要走到头的。</span></p><p><img src="./img/2022-05-05 21-31-40 的屏幕截图.png" style="zoom:67%;" /></p><p><strong><span>C-SCAN</span></strong><span>：The head moves from one end of the disk to the other, servicing requests as it goes. When it reaches the other end, it immediately returns to the beginning of the disk, without servicing any requests on the return trip.</span></p><p><img src="./img/2022-05-05 21-33-43 的屏幕截图.png" style="zoom:67%;" /></p><p><strong><span>C-LOOK</span></strong><span>：Arm only goes as far as the last request in each direction, then reverses direction immediately, without first going all the way to the end of the disk.</span></p><p><img src="./img/2022-05-05 21-35-24 的屏幕截图.png" style="zoom:67%;" /></p><p><span>对于磁盘来说，最影响性能的就是寻道时间和旋转延迟，所以一次只读取一个或两个扇区的效率是非常低的。出于这个原因，许多磁盘控制器总是读出多个扇区并进行高速缓存，即使只请求一个扇区时也是这样。一般情况下读取一个扇区的同时会读取该扇区所在的磁道或者是所有剩余的扇区被读出，读出扇区的数量取决于控制器的高速缓存中有多少可用的空间。</span></p><h4 id='544-错误处理'><span>5.4.4 错误处理</span></h4><p><span>磁盘在制造的过程中可能会有瑕疵，如果瑕疵比较小，比如只有几位，那么使用坏扇区并且每次只是让 ECC 纠正错误是可行的，如果瑕疵较大，那么错误就不可能被掩盖。这就需要备用扇区了。有如下两种替换策略：</span></p><p><img src="./img/mos5.4.4.jpg" style="zoom:67%;" /></p><p><span>如何实现上面的映射呢，可以由控制器或者操作系统实现。可以通过内部的表来跟踪这一信息，或者通过重写前导码来给出重新映射的扇区号。具体细节不展开。</span></p><p><em><span>5.4.5 稳定存储器没有看</span></em></p><h3 id='55-其他'><span>5.5 其他</span></h3><p><span>接下来书上洋洋洒洒花了40页篇幅介绍了时钟、键盘、鼠标、显示器、</span><strong><span>瘦客户机（thin client）</span></strong><span>、以及电源管理。瘦客户机似乎没有明确的定义，可以看看google的Chromebook。个人觉得这些东西对目前我来说并不是什么重要的话题，其实也没有看书上相关内容。</span></p><hr /><div style="page-break-after: always;"></div> <h2 id='六死锁'><span>六、死锁</span></h2><h3 id='61-引入'><span>6.1 引入</span></h3><h4 id='611-定义'><span>6.1.1 定义</span></h4><p><span>首先回答，何为</span><strong><span>死锁（deadlock）</span></strong><span>？</span></p><ul><li><p><strong><span>正式定义</span></strong><span>：</span></p><blockquote><p><span>A set of process is deadlocked if each process in the set is waiting for an event that only another process in the set can cause.</span></p></blockquote></li><li><p><strong><span>翻译一下：</span></strong></p><p><span>一个集合中的所有进程都在等待该集合中的其他进程能产生的事件，我们称这些进程中产生了死锁。而正是因为所有的进程都在等待，所以没有进程能产生唤醒其他进程的事件，这导致大家一起睡觉，活都不干了。</span></p></li></ul><p><span>再</span><strong><span>举个🌰:</span></strong></p><ul><li><strong><span>文字描述：</span></strong><span>进程A持有资源1，请求资源2；进程B持有资源2，请求资源1。此时产生了死锁。进程A和B永远阻塞下去。</span></li><li><strong><span>信号量描述：</span></strong><span>（注意到这里的信号量其实就是资源）</span></li></ul><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// code with a potential deadlock</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">resouce_1</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">semaphore</span> <span class="cm-variable">resouce_2</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">process_A</span>(<span class="cm-variable-3">void</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resouce_1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_2</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">use_both_resource</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_2</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">process_B</span>(<span class="cm-variable-3">void</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resouce_2</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">down</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">use_both_resource</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">up</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_2</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 385px;"></div><div class="CodeMirror-gutters" style="display: none; height: 385px;"></div></div></div></pre><h4 id='612-资源'><span>6.1.2 资源</span></h4><p><span>继续下去前，需要明确</span><strong><span>资源（resouce）</span></strong><span>的含义。</span></p><ul><li><p><strong><span>是什么</span></strong><span>：anything that must be acquired, used, and released over the course of time, including hardware devices (e.g. a Blu-ray drive), data records (i.e. something in a database), files, and so forth</span></p></li><li><p><strong><span>分类：</span></strong><span>可抢占和不可抢占</span></p><ul><li><strong><span>preemptable resource</span></strong><span>: can be taken away from the process owning it with no ill effects. For example, memory is usually  a kind of preemptable resource, for pages can always be swapped out to disk to recover it.</span></li><li><strong><span>nonpreemptable resource</span></strong><span>: cannot be taken away from its current owner without potentially causing failure. For example, If a process has begun to burn a Blu-ray, suddenly taking the Blu-ray recorder away from it and giving it to another process will result in a garbled Blu-ray.</span></li><li><span>需要明确，是否是可抢占还需要看具体实现，比如在一个不支持swapping和paging的手机上，我们无法通过页交换来避免死锁。此时内存就变成了不可抢占资源。</span></li></ul></li></ul><p><span>进程请求资源、使用资源、最后释放资源。</span><strong><span>我们假定无法请求到所有资源的进程会阻塞，但阻塞时并不会释放已经占有的资源；我们还假定请求到所有资源的进程在有限时间内（工作结束后）会释放所有资源，而不是永久占用下去。</span></strong></p><p><span>注意到我们现在讨论的死锁都是</span><strong><span>资源死锁（resource deadlock）</span></strong><span>，是由于进程永久等待等不到的不可抢占资源所产生的死锁。可能是最常见的死锁类型了，其他类型我们按下不表。</span></p><h4 id='613-产生条件'><span>6.1.3 产生条件</span></h4><p><span>应该是资源死锁的充要条件吧，一共四条：</span></p><ol start='' ><li><strong><span>Mutual exclusion condition</span></strong><span>. Each resource is either currently assigned to exactly one process or is available.</span></li><li><strong><span>Hold-and-wait condition</span></strong><span>. Process currently holding resources that were granted earlier can request new resources.</span></li><li><strong><span>No-preemption condition</span></strong><span>. Resources previously granted cannot be forcibly taken away from a process. They must be explicitly released by the process holding them.</span></li><li><strong><span>Circular wait condition</span></strong><span>. There must be a circular list of two or more processes, each of which is waiting for a resource held by the next member of the chain.</span></li></ol><h4 id='614-资源分配图'><span>6.1.4 资源分配图</span></h4><p><img src="./img/image-20220326111827468.png" alt="image-20220326111827468" style="zoom:20%;" /></p><p><span>在</span><strong><span>资源分配图（resource allocation graph）</span></strong><span>中，进程用圆圈表示，资源用方块表示。图a表示进程A持有资源R；图b表示进程B请求资源S，求之不得，于是阻塞；图c意指，图中有环与死锁充要（仅在一种资源单个的情况下成立）。</span></p><p><span>对于一种资源有多个的情况，也可以利用资源分配图表示，下图摘自恐龙书：</span></p><p><img src="./img/2022-03-26 11-26-29 的屏幕截图.png" alt="image-20220326111827468" style="zoom:40%;" /></p><p><span>注意到，此时有环，并不意味着有死锁。上图中，P2用完R1会归还，P4用完R2会归还，死锁不会产生。</span></p><h4 id='615-解决策略'><span>6.1.5 解决策略</span></h4><p><span>解决死锁有四个策略：</span></p><ol start='' ><li><span>Just </span><strong><span>ignore</span></strong><span> the problem. Maybe if you ignore it, it will ignore you.</span></li><li><span>Detection and </span><strong><span>recovery</span></strong><span>. Let them occur, detect them, and take action.</span></li><li><span>Dynamic </span><strong><span>avoidance</span></strong><span> by careful resource allocation.</span></li><li><strong><span>Prevention</span></strong><span>, by structurally negating one of the four conditions (mentioned in 6.1.3).</span></li></ol><p><span>下面6.2～6.5节依次讨论上述解决策略。</span></p><h3 id='62-鸵鸟算法'><span>6.2 鸵鸟算法</span></h3><p><span>鸵鸟算法（ostrich algorithm）就是直接忽略问题。对于那些几乎不发生、解决起来特别麻烦的死锁问题，忽视这种死锁的存在是一个说的过去的算法。</span></p><h3 id='63-死锁检测和修复'><span>6.3 死锁检测和修复</span></h3><p><span>让死锁发生，找到它，并修复它。</span></p><h4 id='631-每种类型一个资源的死锁检查'><span>6.3.1 每种类型一个资源的死锁检查</span></h4><p><span>利用6.1.4节中的资源分配图，判断该有向图是否无环，无环则没有死锁，有环则存在死锁。判断算法利用DFS就好了，这里不再展开。</span></p><h4 id='632-每种类型多个资源的死锁检查'><span>6.3.2 每种类型多个资源的死锁检查</span></h4><p><span>由6.1.4节可见，当每种类型有多个资源时，有环已经不能作为存在死锁的判据了。需要提出新的算法，其实也很自然。</span></p><p><span>维护四个矩阵E (existing resource vector)、A (available resource vector)、C (current allocation matrix)、R (request matrix)，定义为：</span></p><p><img src="./img/image-20220326134854959.png" alt="image-20220326134854959" style="zoom:25%;" /></p><p><span>显然四个矩阵具有等式：</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n1417" cid="n1417" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="17.504ex" height="6.354ex" role="img" focusable="false" viewBox="0 -1562.5 7736.6 2808.5" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -2.819ex;"><defs><path id="MJX-4-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-4-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-4-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-4-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-4-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-4-TEX-I-1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path><path id="MJX-4-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path><path id="MJX-4-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-4-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-4-TEX-I-1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><use data-c="2211" xlink:href="#MJX-4-TEX-LO-2211"></use></g><g data-mml-node="TeXAtom" transform="translate(148.2,-1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-4-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345,0)"><use data-c="3D" xlink:href="#MJX-4-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1123,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"></use></g></g><g data-mml-node="mi" transform="translate(509.9,1150) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-4-TEX-I-1D45B"></use></g></g><g data-mml-node="msub" transform="translate(1610.7,0)"><g data-mml-node="mi"><use data-c="1D436" xlink:href="#MJX-4-TEX-I-1D436"></use></g><g data-mml-node="TeXAtom" transform="translate(748,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-4-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(345,0)"><use data-c="1D457" xlink:href="#MJX-4-TEX-I-1D457"></use></g></g></g><g data-mml-node="mo" transform="translate(3166.2,0)"><use data-c="2B" xlink:href="#MJX-4-TEX-N-2B"></use></g><g data-mml-node="msub" transform="translate(4166.4,0)"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-4-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(783,-150) scale(0.707)"><use data-c="1D457" xlink:href="#MJX-4-TEX-I-1D457"></use></g></g><g data-mml-node="mo" transform="translate(5568.5,0)"><use data-c="3D" xlink:href="#MJX-4-TEX-N-3D"></use></g><g data-mml-node="msub" transform="translate(6624.3,0)"><g data-mml-node="mi"><use data-c="1D438" xlink:href="#MJX-4-TEX-I-1D438"></use></g><g data-mml-node="mi" transform="translate(771,-150) scale(0.707)"><use data-c="1D457" xlink:href="#MJX-4-TEX-I-1D457"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><munderover><mo data-mjx-texclass="OP">∑</mo><mrow data-mjx-texclass="ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>C</mi><mrow data-mjx-texclass="ORD"><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>A</mi><mi>j</mi></msub><mo>=</mo><msub><mi>E</mi><mi>j</mi></msub></math></mjx-assistive-mml></mjx-container></div></div><p><span>再定义行向量</span><mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="34.174ex" height="2.084ex" role="img" focusable="false" viewBox="0 -716 15104.8 921" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.464ex;"><defs><path id="MJX-30-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-30-TEX-N-2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path><path id="MJX-30-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path><path id="MJX-30-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path><path id="MJX-30-TEX-N-A0" d=""></path><path id="MJX-30-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-30-TEX-I-1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path><path id="MJX-30-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-30-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-30-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-30-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-30-TEX-I-1D434"></use></g><g data-mml-node="mo" transform="translate(1027.8,0)"><use data-c="2264" xlink:href="#MJX-30-TEX-N-2264"></use></g><g data-mml-node="mi" transform="translate(2083.6,0)"><use data-c="1D435" xlink:href="#MJX-30-TEX-I-1D435"></use></g><g data-mml-node="mo" transform="translate(2842.6,0)"><use data-c="2C" xlink:href="#MJX-30-TEX-N-2C"></use></g><g data-mml-node="mtext" transform="translate(3287.2,0)"><use data-c="A0" xlink:href="#MJX-30-TEX-N-A0"></use></g><g data-mml-node="mi" transform="translate(3537.2,0)"><use data-c="1D456" xlink:href="#MJX-30-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(3882.2,0)"><use data-c="1D453" xlink:href="#MJX-30-TEX-I-1D453"></use></g><g data-mml-node="mi" transform="translate(4432.2,0)"><use data-c="1D453" xlink:href="#MJX-30-TEX-I-1D453"></use></g><g data-mml-node="mtext" transform="translate(4982.2,0)"><use data-c="A0" xlink:href="#MJX-30-TEX-N-A0"></use></g><g data-mml-node="msub" transform="translate(5232.2,0)"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-30-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(783,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-30-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(6587,0)"><use data-c="2264" xlink:href="#MJX-30-TEX-N-2264"></use></g><g data-mml-node="msub" transform="translate(7642.7,0)"><g data-mml-node="mi"><use data-c="1D435" xlink:href="#MJX-30-TEX-I-1D435"></use></g><g data-mml-node="mi" transform="translate(792,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-30-TEX-I-1D456"></use></g></g><g data-mml-node="mtext" transform="translate(8728.7,0)"><use data-c="A0" xlink:href="#MJX-30-TEX-N-A0"></use></g><g data-mml-node="mi" transform="translate(8978.7,0)"><use data-c="1D453" xlink:href="#MJX-30-TEX-I-1D453"></use></g><g data-mml-node="mi" transform="translate(9528.7,0)"><use data-c="1D45C" xlink:href="#MJX-30-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(10013.7,0)"><use data-c="1D45F" xlink:href="#MJX-30-TEX-I-1D45F"></use></g><g data-mml-node="mtext" transform="translate(10464.7,0)"><use data-c="A0" xlink:href="#MJX-30-TEX-N-A0"></use></g><g data-mml-node="mn" transform="translate(10714.7,0)"><use data-c="31" xlink:href="#MJX-30-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(11492.5,0)"><use data-c="2264" xlink:href="#MJX-30-TEX-N-2264"></use></g><g data-mml-node="mi" transform="translate(12548.2,0)"><use data-c="1D456" xlink:href="#MJX-30-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(13171,0)"><use data-c="2264" xlink:href="#MJX-30-TEX-N-2264"></use></g><g data-mml-node="mi" transform="translate(14226.8,0)"><use data-c="1D45A" xlink:href="#MJX-30-TEX-I-1D45A"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi><mo>≤</mo><mi>B</mi><mo>,</mo><mtext>&nbsp;</mtext><mi>i</mi><mi>f</mi><mi>f</mi><mtext>&nbsp;</mtext><msub><mi>A</mi><mi>i</mi></msub><mo>≤</mo><msub><mi>B</mi><mi>i</mi></msub><mtext>&nbsp;</mtext><mi>f</mi><mi>o</mi><mi>r</mi><mtext>&nbsp;</mtext><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></math></mjx-assistive-mml></mjx-container><script type="math/tex">A\leq B,\ iff\ A_i \leq B_i\ for\ 1\leq i\leq m</script><span>. 于是乎，有这样很自然的算法：</span></p><ol start='' ><li><span>Look for an unmarked process, Pi, for which the ith row of R is less than or equal to A.</span></li><li><span>If such a process is found, add the ith row of C to A, mark the process, and go back to step 1.</span></li><li><span>If no such process exists, the algorithm terminates. When the algorithm terminates, all the unmarked processes, if any, are deadlocked.</span></li></ol><p><span>什么时候运行该算法呢？有这么几种参考：</span></p><ul><li><span>每当资源请求发生时。优势：尽早发生问题；劣势：占用过多CPU时间</span></li><li><span>每k分钟检查一次</span></li><li><span>当CPU使用率低于某个阈值时</span></li></ul><h4 id='633-从死锁中恢复'><span>6.3.3 从死锁中恢复</span></h4><p><span>发现死锁后就要处理喽，有这么三种想法</span></p><p><strong><span>Recovery through Preemption</span></strong></p><p><span>从当前拥有者那里抢占资源。在很多时候需要人工介入，特别是大型机的批处理系统。比如打印机打文件A打了一半，我给它中止掉，把打好的部分文件A先放在一边，然后叫打印机去打印文件B，文件B打好后，再从文件A剩余部分开始打印。</span></p><p><span>资源的可抢占性主要取决于资源本身，把资源还给被抢占的进程并不是一件易事。</span></p><p><strong><span>Recovery through Rollback</span></strong></p><p><span>设置</span><strong><span>检查点（checkpoint）</span></strong><span>，记录下此时进程的内存快照、资源状态等。When a deadlock is detected, it is to see which resources are needed. To do the recovery, a process that owns a needed resource is rolled back to a point in time before it acquired that resource by starting at one of its earlier checkpoints.</span></p><p><strong><span>Recovery through Killing Processes</span></strong></p><p><span>杀死一些进程来释放所需的资源。最理想的杀死目标是那些可以从头重新运行且不会造成坏影响的进程，比如编译器。</span></p><h3 id='64-死锁避免'><span>6.4 死锁避免</span></h3><p><span>在讨论死锁检查时，我们默认进程请求资源是一蹴而就的，但实际上大部分系统资源都是一个一个请求的。那我们分配资源的时候，有没有算法来制定分配顺序来避免死锁呢？答案是有的，但是要率先知道一些特定的信息。</span></p><h4 id='641-资源轨迹图'><span>6.4.1 资源轨迹图</span></h4><p><span>这里用</span><strong><span>资源轨迹图（resource trajectory）</span></strong><span>来给出一个直观的理解。</span></p><p><span>这里假设只有一个打印机和一个绘图机。一些读图提示（我懒的写详细了）：在指令I</span><sub><span>1</span></sub><span>到I</span><sub><span>3</span></sub><span>时进程A使用打印机；虚线上的点的横坐标对应着进程A执行到的指令，纵坐标对应着进程B执行到的指令；虚线只能朝上或者朝右走；I</span><sub><span>1,2,...,8</span></sub><span>之间还有指令的。</span></p><p><img src="./img/image-20220326161608420.png" alt="image-20220326161608420" style="zoom:20%;" /></p><h4 id='642-安全状态和不安全状态'><span>6.4.2 安全状态和不安全状态</span></h4><p><span>当存在一种执行顺序，使得进程们不会产生死锁，那称它们处于</span><strong><span>安全状态（safe state）</span></strong><span>；否则称为</span><strong><span>不安全状态（unsafe state）</span></strong><span>。举个例子，现在资源有10份，ABC三个进程如下：</span></p><figure><table><thead><tr><th><span>情况1</span></th><th><span>已占有</span></th><th><span>总需要</span></th><th>&nbsp;</th><th><span>情况2</span></th><th><span>已占有</span></th><th><span>总需要</span></th></tr></thead><tbody><tr><td><span>A</span></td><td><span>3</span></td><td><span>9</span></td><td>&nbsp;</td><td><span>A</span></td><td><span>4</span></td><td><span>9</span></td></tr><tr><td><span>B</span></td><td><span>2</span></td><td><span>4</span></td><td>&nbsp;</td><td><span>B</span></td><td><span>2</span></td><td><span>4</span></td></tr><tr><td><span>C</span></td><td><span>2</span></td><td><span>7</span></td><td>&nbsp;</td><td><span>C</span></td><td><span>2</span></td><td><span>7</span></td></tr></tbody></table></figure><p><span>情况1就是处于安全状态，我们可以先把三份空闲资源中两份给B，B运行完后空闲资源有5份，然后全部分配给C，C运行完空闲资源编程7份，取六份给A就行了。相应的，情况2就处于不安全状态。</span></p><p><span>注意到不安全不意味着死锁。情况2的进程B可以运行结束，再若进程C可以抢占进程A中的一份资源（或者A somehow就释放了一份资源，日后再获取它），那么所有进程都可以运行结束。</span><strong><span>不安全只是意味着没有保障来保证所有进程都可以结束，而不是进程一定不可以结束。</span></strong></p><h4 id='643-单种资源的银行家算法'><span>6.4.3 单种资源的银行家算法</span></h4><p><span>简单来说，就是每次请求发生后，我看看若满足它的请求，会不会进入不安全状态，如果会的话，就推迟这个请求，不会的话，就满足这个请求。比如总共十份资源，进程ABCD三个时刻为：</span></p><figure><table><thead><tr><th><span>进程</span></th><th><span>时刻1</span></th><th><span>时刻2</span></th><th><span>时刻3</span></th><th><span>总需要</span></th></tr></thead><tbody><tr><td><span>A</span></td><td><span>1</span></td><td><span>1</span></td><td><span>1</span></td><td><span>6</span></td></tr><tr><td><span>B</span></td><td><span>0</span></td><td><span>1</span></td><td><span>2</span></td><td><span>5</span></td></tr><tr><td><span>C</span></td><td><span>2</span></td><td><span>2</span></td><td><span>2</span></td><td><span>4</span></td></tr><tr><td><span>D</span></td><td><span>4</span></td><td><span>4</span></td><td><span>4</span></td><td><span>7</span></td></tr></tbody></table></figure><p><span>时刻2是安全的，于是对于时刻1进程B的请求要满足；时刻3是不安全的，于是对于时刻2进程B的请求要推迟。</span></p><p><span>称之为</span><strong><span>银行家算法（banker&#39;s algorithm）</span></strong><span>，是因为“总需要”如同</span><strong><span>信用额度（credit line）</span></strong><span>，每时刻进程占据的资源数目如同已经向银行贷款的数目。</span></p><h4 id='644-多种资源的银行家算法'><span>6.4.4 多种资源的银行家算法</span></h4><p><span>就是6.3.2中判断死锁的算法。。。唯一改变是R (request matrix)被明确定义为进程还需要的资源，之前是进程总共所需的资源。现在强调我已经占据了一些资源，目前还需要多少资源。</span></p><p><span>银行家算法最早由Dijkstra在1965年提出，从此讨论该算法的文章层出不穷，但是事实上该算法没什么用，因为进程难以提前知道它总共需要的资源数。</span></p><h3 id='65-死锁预防'><span>6.5 死锁预防</span></h3><p><span>避免死锁几乎不可能。在实际情况下，我们更多地通过破坏6.1.3中提出来的四个条件中的任何一个，就可以从结构上来</span><strong><span>预防（prevent）</span></strong><span>死锁。总结为：</span></p><figure><table><thead><tr><th><span>Condition</span></th><th><span>Approach</span></th></tr></thead><tbody><tr><td><span>Mutual exclusion</span></td><td><span>Spool everything</span></td></tr><tr><td><span>Hold and wait</span></td><td><span>Request all resources initially</span></td></tr><tr><td><span>No preemption</span></td><td><span>Take resources away</span></td></tr><tr><td><span>Circular wait</span></td><td><span>Order resources numerically</span></td></tr></tbody></table></figure><h4 id='651-破坏互斥条件'><span>6.5.1 破坏互斥条件</span></h4><p><span>如果资源不再可以被互斥地分配给进程，就可以避免死锁。一个想法是通过</span><strong><span>假脱机（spooling）</span></strong><span>实现，也就是先把数据存储到</span><strong><span>spooling directory</span></strong><span>，然后只允许一个特殊的进程（</span><strong><span>daemon，守护进程</span></strong><span>）访问。比如只允许打印机守护进程（printer daemon）访问物理打印机，其他进程只是将要打印内容写到某个地方（spooling space），这就不会产生因打印机而产生死锁了。当然若spooling space太小，两个进程文件都才写到一半，还是会产生死锁。</span></p><h4 id='652-破坏占有并等待条件'><span>6.5.2 破坏占有并等待条件</span></h4><p><span>如果我们不允许持有资源的进程等待其他资源，就可以避免死锁。一种实现方法是，进程在开始执行前就请求所有的资源。困难：进程难以在开始前知道需要多少资源。劣势：资源没有充分利用，出现占着茅坑不拉屎。但是确实有些大型机的批处理系统要求用户在每个任务前列出所需资源。</span></p><h4 id='653-破坏不可抢占条件'><span>6.5.3 破坏不可抢占条件</span></h4><p><span>哈，我缺少资源A，那就从别的进程抢一个过来！想法很恶劣，但是虚拟化可以帮助破坏不可抢占条件。比如6.5.1提及的</span><strong><span>假脱机（spooling）</span></strong><span>，打印机就被虚拟化了。但是一个资源能不能虚拟化取决于资源本身特性。</span></p><h4 id='654-破坏环路等待条件'><span>6.5.4 破坏环路等待条件</span></h4><p><span>一个想法是，我把所有资源排好序，进程必须按照顺序请求资源。其实挺好理解的，设置6.1.1中的进程A与进程B关于两个资源的请求顺序相同，就可以避免死锁。难点在于，如何设置顺序来满足所有人。</span></p><h3 id='66-其他问题'><span>6.6 其他问题</span></h3><h4 id='661-两阶段加锁'><span>6.6.1 两阶段加锁</span></h4><p><span>对于数据库系统，我们可以采用</span><strong><span>两阶段加锁（two-phase locking）</span></strong><span>：</span></p><ul><li><span>first phase: The process tries to lock all the records (就当作是数据库中的数据吧，record具体是啥我也不清楚) it needs, one at a time. If it succeeds, it begins the second phase.</span></li><li><span>second phase: The process performs its updates and releases the locks.</span></li></ul><p><span>就是6.5.2的思路。</span></p><h4 id='662-通信死锁'><span>6.6.2 通信死锁</span></h4><p><span>之前我们讨论的资源死锁是</span><strong><span>竞争同步（competition synchronization）</span></strong><span>所产生的问题，在6.1.2曾提及死锁种类不止一种，对于</span><strong><span>协作同步（cooperation synchronization）</span></strong><span>，我们会产生</span><strong><span>通信死锁（communication deadlock）</span></strong><span>。前者是因为资源被占用而产生的死锁，后者是因为进程无法独立进行而产生的死锁。</span></p><p><span>考虑一个网络上，进程A发送了消息给进程B，然后阻塞等待B的回复，B回复完也阻塞了，结果B的回复丢失了，这就导致两个进程全阻塞了，也就是产生了死锁。我们可以设置</span><strong><span>超时（timeout）</span></strong><span>，让一段时间没有收到回复消息的进程重新发送消息。这同样也产生了一个麻烦，如果消息并没有丢失，而是延迟了，进程可能会收到两个相同的消息。此时我们需要设置网络协议来解决这类问题。将在计网中深入讨论。</span></p><p><span>当然并不是说计算机通信过程中没有资源死锁了。比如AB两个路由器中所有的缓存都满了，A要发送数据给B，B要发送数据给A，这就产生了资源死锁。</span></p><h4 id='663-活锁'><span>6.6.3 活锁</span></h4><p><strong><span>活锁（livelock）</span></strong><span>就像两个人过马路，同时谦让对方，结果通通过不了。此时并没有进程阻塞，但是没有任何进展。举个例子，</span><code>try_lock</code><span>尝试获取锁，如果失败不会阻塞；</span><code>acquire_lock</code><span>尝试获取锁，失败会阻塞。下面是个活锁的例子：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="c" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="c"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.33333px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">// Polite process can cause livelock</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">process_A</span>(){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">acquire_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span> (<span class="cm-variable">try_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_2</span>) <span class="cm-operator">==</span> <span class="cm-variable">fail</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">release_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">wait_fixed_time</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">acquire_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">use_both_resources</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">release_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_2</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">release_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable-3">void</span> <span class="cm-def">process_B</span>(){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">acquire_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_2</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">while</span> (<span class="cm-variable">try_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_1</span>) <span class="cm-operator">==</span> <span class="cm-variable">fail</span>){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">release_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_2</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">wait_fixed_time</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">acquire_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_2</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">use_both_resources</span>();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">release_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_1</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-variable">release_lock</span>(<span class="cm-operator">&amp;</span><span class="cm-variable">resource_2</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 521px;"></div><div class="CodeMirror-gutters" style="display: none; height: 521px;"></div></div></div></pre><h4 id='664-饥饿'><span>6.6.4 饥饿</span></h4><p><strong><span>饥饿（starvation）</span></strong><span>是指：进程永远没法得到一些服务，尽管没有死锁。比如优先级的调度算法，就会产生低优先级进程饿死。可以用FCFS（first-come, first-served）解决。</span></p><hr /><div style="page-break-after: always;"></div> <h2 id='七分布式系统结构'><span>七、分布式系统结构</span></h2><p><span>从这章开始就不是《现代操作系统》上的内容了，而是根据上海交通大学cs2302课程最后三节课（六课时）所讲述的内容，进行一点非常简单的整理。主要为了最后的期末考试。本章内容由四课时讲述。</span></p><p><span>需要回答的问题：</span></p><ul><li><span>What is better, loosely coupled or tightly coupled?</span></li><li><span>Why is distributed OS more advanced than network OS?</span></li><li><span>Compare complete network, line and ring? What is your choice?</span></li><li><span>How to guarantee each process has a unique name even in a distributed system?</span></li><li><span>Which routing algorithm is used in TCP/IP, fixed routing or dynamic routing?</span></li><li><span>Why does TCP/IP use packet switching, not circuit switching?</span></li><li><span>How many steps are included in CSMA/CD?</span></li><li><span>Why a communication network is partitioned into multiple layers?</span></li><li><span>How to control flow rate at transportation layer?</span></li><li><span>What is main purpose of headers?</span></li></ul><p><span>下面就逐一回答</span></p><p><strong><span>What is better, loosely coupled or tightly coupled?</span></strong></p><p><span>关于loosely coupled和tightly coupled的定义如下，优劣如下：</span></p><p><img src="./img/2022-05-26 10-57-15 的屏幕截图.png" style="zoom:50%;" /></p><p><span>而分布式系统的定义是</span><mark><span>Distributed system is collection of loosely coupled processors interconnected by a communications network</span></mark></p><p><span>自然答案是loosely coupled</span></p><p>&nbsp;</p><p><strong><span>Why is distributed OS more advanced than network OS?</span></strong></p><p><strong><span>网络操作系统（network operating system）</span></strong><span>下，Users </span><mark><span>are aware of</span></mark><span> multiplicity of machines. Access to resources of various machines is done explicitly by:</span></p><ul><li><span>Remote logging into the appropriate remote machine (telnet, ssh)</span></li><li><span>Remote Desktop (Microsoft Windows)</span></li><li><span>Transferring data from remote machines to local machines, via the File Transfer Protocol (FTP) mechanism</span></li></ul><p><span>而分布式操作系统下，Users are </span><mark><span>not aware of</span></mark><span> multiplicity of machines. Access to remote resources similar to access to local resources. 我们可以实现不同处理器见传送数据、计算和进程（不同地方site的处理器负责一个进程的不同部分）</span></p><p>&nbsp;</p><p><strong><span>Compare complete network, line and ring? What is your choice?</span></strong></p><p><span>网络有各种各样的拓扑结构（topology），如：</span></p><p><img src="./img/2022-05-26 11-07-29 的屏幕截图.png" style="zoom: 67%;" /></p><p><span>在分析优劣时，需要考虑：</span></p><ul><li><strong><span>Installation cost</span></strong><span>: How expensive is it to link the various sites in the system?</span></li><li><strong><span>Communication cost</span></strong><span>: How long does it take to send a message from site A to site B?</span></li><li><strong><span>Reliability</span></strong><span>: If a link or a site in the system fails, can the remaining sites still communicate with each other?</span></li></ul><p>&nbsp;</p><p><strong><span>How to guarantee each process has a unique name even in a distributed system?</span></strong></p><p><span>我们可以Name systems in the network +  Address messages with the process-id。然后就可以Identify processes on remote systems by &lt;host-name, identifier&gt; pair</span></p><p><span>在TCP/IP下，在Transport layer，可以通过 &lt;IP, port number&gt; pair to locate a process</span></p><p>&nbsp;</p><p><strong><span>Which routing algorithm is used in TCP/IP, fixed routing or dynamic routing?</span></strong></p><p><strong><span>路由选择策略（routing strategies）</span></strong><span>也就是如何决定数据通过哪些路径传播，介绍了以下三种</span></p><ul><li><strong><span>Fixed routing</span></strong><span>: 固定一条路径。A path from A to B is specified in advance; path changes only if a hardware failure disables it. 优点：Since the shortest path is usually chosen, communication costs are minimized; Ensures that messages will be delivered in the order in which they were sent. 缺点：Fixed routing cannot adapt to load changes</span></li><li><strong><span>Virtual circuit</span></strong><span>: 在一个session内固定一条路径。A path from A to B is fixed for the duration of one session. Different sessions involving messages from A to B may have different paths. 优点：Ensures that messages will be delivered in the order in which they were sent. 较fixed routing有所改进的点：Partial remedy to adapting to load changes</span></li><li><strong><span>Dynamic routing</span></strong><span>: 动态选择路径。The path used to send a message form site A to site B is chosen only when a message is sent. 优点：Adapts to load changes by avoiding routing messages on heavily used path. 缺点：Messages may arrive out of order （可解决）</span></li></ul><p><span>TCP/IP采用dynamic routing</span></p><p>&nbsp;</p><p><strong><span>Why does TCP/IP use packet switching, not circuit switching?</span></strong></p><p><strong><span>交换（switching）</span></strong><span>讨论的是两个处理器如何传递信息。介绍了以下三种：</span></p><ul><li><p><strong><span>Circuit switching</span></strong><span>: A </span><mark><span>permanent physical link</span></mark><span> is established for the duration of the communication (i.e., telephone system)</span></p></li><li><p><strong><span>Message switching</span></strong><span>: A </span><mark><span>temporary link</span></mark><span> is established for the duration of one message transfer (i.e., post-office mailing system)</span></p></li><li><p><strong><span>Packet switching</span></strong><span>: Messages of variable length are divided into fixed-length packets which are sent to the destination. 更多人可以同时使用，发挥出全部带宽。特点：</span></p><ul><li><span>Each packet may take a different path through the network</span></li><li><span>The packets must be reassembled into messages as they arrive</span></li></ul></li></ul><p><span>优劣对比：Circuit switching requires more setup time, but incurs less overhead for shipping each message, and may waste network bandwidth. Message and packet switching require less setup time, but incur more overhead per message</span></p><p>&nbsp;</p><p><strong><span>How many steps are included in CSMA/CD?</span></strong></p><p><span>CSMA/CD是Carrier sense with multiple access (CSMA); collision detection (CD)</span></p><ol start='' ><li><span>检查是否有其他人在使用carrier，如果有人在使用，就随机等待一段时间，再检查</span></li><li><span>但是还是可能产生collision，如果有collision，过一会儿重新发数据</span></li></ol><p>&nbsp;</p><p><strong><span>Why a communication network is partitioned into multiple layers?</span></strong></p><p><span>将复杂的模型分层可以使得各层简单，容易管理。OSI网络模型有七层。</span></p><p><img src="./img/2022-05-26 13-43-21 的屏幕截图.png" style="zoom:67%;" /></p><p><span>实际上我们使用的TCP/IP协议只有OSI网络模型的部分层。</span></p><p>&nbsp;</p><p><strong><span>How to control flow rate at transportation layer?</span></strong></p><p><span>采用TCP congestion control，如下图：</span></p><p><img src="./img/2022-05-26 13-44-40 的屏幕截图.png" style="zoom:67%;" /></p><p>&nbsp;</p><p><strong><span>What is main purpose of headers?</span></strong></p><p><span>每层都有一个header，为了协议的实现。Headers provide a space for computer A and computer B to implement protocols for each layer.</span></p><p><img src="./img/2022-05-26 13-48-35 的屏幕截图.png" style="zoom:50%;" /></p><hr /><div style="page-break-after: always;"></div> <h2 id='八分布式文件系统'><span>八、分布式文件系统</span></h2><p><span>同样的，这部分内容也不是《现代操作系统》上的内容，而是根据cs2302简单整理得到。本章内容由两课时讲述。</span><em><span>我只整理了我看得懂的地方（PPT和课都粗糙），但是我甚至觉得这里期末都不考的</span></em></p><p><strong><span>Goal</span></strong></p><p><strong><span>分布式文件系统（distributed file system, DFS）</span></strong><span>的最终目标是使得DFS看起来就是一个常规的文件系统。即便不同文件分布在不同地方的磁盘中，但是它们由网络相连，看起来就是一个整体。用户只需要用常规的系统调用访问就可以了，无需知道文件究竟存在何处。</span></p><p>&nbsp;</p><p><strong><span>Transparency</span></strong></p><p><span>包含两个：</span></p><ul><li><strong><span>Location transparency</span></strong><span>: file name does not reveal the file’s physical storage location。大部分DFS支持</span></li><li><strong><span>Location independence</span></strong><span>: file name does not need to be changed when the file’s physical storage location changes。少部分DFS支持</span></li></ul><p>&nbsp;</p><p><strong><span>Naming Schemes</span></strong></p><p><span>如何给文件命名，有：</span></p><ul><li><p><span>命名包含host name和local name。supports neither Location independence nor Location transparency</span></p></li><li><p><span>把远程目录挂载到本地目录下。</span></p></li><li><p><span>Total integration of the component file systems. </span></p><ul><li><span>A single global name structure spans all the files in the system</span></li><li><span>If a server is unavailable, some arbitrary set of directories on different machines also becomes unavailable</span></li></ul></li></ul><p>&nbsp;</p><p><strong><span>Remote file access</span></strong></p><p><span>有两种：</span></p><ul><li><strong><span>remote service</span></strong><span>: use remote procedure call (RPC) to support remote file access。似乎每次都要去远程电脑读取数据？</span></li><li><strong><span>caching</span></strong><span>: 把所需要从远程电脑获取的数据缓存在本地，快，缓存一致性问题。</span></li></ul><p><em><span>挺奇怪的，反正我觉得</span></em></p><p><img src="./img/2022-05-30 15-36-18 的屏幕截图.png" style="zoom: 50%;" /></p><p>&nbsp;</p><p><strong><span>Stateful and stateless</span></strong></p><ul><li><strong><span>无状态服务（stateless service）</span></strong><span>对单次请求的处理，不依赖其他请求，也就是说，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（比如说数据库），服务器本身不存储任何信息</span></li><li><strong><span>有状态服务（stateful service）</span></strong><span>则相反，它会在自身保存一些数据，先后的请求是有关联的。譬如先调用</span><code>open</code><span>打开文件得到一个identifier，然后再由这个identifier进行后续操作。性能更好，但是failure recovery更困难。</span></li></ul><p>&nbsp;</p><p><strong><span>Andrew file system (AFS)</span></strong></p><p><span>就三张图：</span></p><ul><li><span>整体</span></li></ul><p><img src="./img/2022-05-30 15-44-10 的屏幕截图.png" style="zoom:50%;" /></p><ul><li><span>workstation</span></li></ul><p><img src="./img/2022-05-30 15-44-18 的屏幕截图.png" style="zoom:50%;" /></p><ul><li><span>implementation of file system calls</span></li></ul><p><img src="./img/2022-05-30 15-44-35 的屏幕截图.png" style="zoom:67%;" /></p></div></div>
</body>
</html>